/*******************************************************************************
 * This file is part of the Polyglot extensible compiler framework.
 *
 * Copyright (c) 2000-2012 Polyglot project group, Cornell University
 * Copyright (c) 2006-2012 IBM Corporation
 * All rights reserved.
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * This program and the accompanying materials are made available under
 * the terms of the Lesser GNU Public License v2.0 which accompanies this
 * distribution.
 *
 * The development of the Polyglot project has been supported by a
 * number of funding sources, including DARPA Contract F30602-99-1-0533,
 * monitored by USAF Rome Laboratory, ONR Grants N00014-01-1-0968 and
 * N00014-09-1-0652, NSF Grants CNS-0208642, CNS-0430161, CCF-0133302,
 * and CCF-1054172, AFRL Contract FA8650-10-C-7022, an Alfred P. Sloan
 * Research Fellowship, and an Intel Research Ph.D. Fellowship.
 *
 * See README for contributors.
 ******************************************************************************/
// Assumes polyglot.jar is in classpath
include "polyglot/parse/java12.cup"

package polyglot.ext.jl5.parse;

import polyglot.ext.jl5.types.*;
import polyglot.ext.jl5.ast.*;
import polyglot.parse.*;

/* Java 1.5 (JSR-14 + JSR-201) parser for CUP.
 * (Well, Java 1.5 as of 28 Jul 2003; it may change before official release)
 * Copyright (C) 2003 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JSR-14 Features added:
* parameterized types, including corrections from the spec released
  with the 2.2 prototype of the JSR-14 compiler.  Arrays of parameterized
  types bounded by wildcards are slated to be added to Java 1.5 (although
  they are not supported by the 2.2 prototype); this grammar supports them.
  "Wildcard" types are supported as of the 28 jul 2003 release.

JSR-201 Features added:
* no changes for autoboxing
* new-style for:
  foreach_statement ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'  -- CSA extension; not (yet?) officially adopted
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement
	;
  foreach_statement_no_short_if ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement_no_short_if
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'  -- CSA extension; not (yet?) officially adopted
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement_no_short_if
	;
  statement ::= ...
     |		foreach_statement ;
  statement_no_short_if ::= ...
     |		foreach_statement_no_short_if ;

* static import:
  static_single_type_import_declaration ::=
		IMPORT STATIC name SEMICOLON
	;
  static_type_import_on_demand_declaration ::=
		IMPORT STATIC name DOT MULT SEMICOLON
	;
  import_declaration ::= ...
	|	static_single_type_import_declaration
	|	static_type_import_on_demand_declaration
	;
* varargs:
 formal_parameter ::= ...
	|	type ELLIPSIS IDENTIFIER
	|	FINAL type ELLIPSIS IDENTIFIER
	;
* enum:
  enum_declaration ::=
		modifiers_or_annotations_opt ENUM IDENTIFIER interfaces_opt enum_body
	;
  enum_body ::=
		LBRACE enum_constants_opt enum_body_declarations_opt RBRACE
	;
  enum_constants_opt ::=
	|	enum_constants
	;
  enum_constants ::=
		enum_constant
	|	enum_constants COMMA enum_constant
	;
  enum_constant ::=
		IDENTIFIER enum_arguments_opt
	|	IDENTIFIER enum_arguments_opt class_body
	;
  enum_arguments_opt ::=
	|	LPAREN argument_list_opt RPAREN
	;
  enum_body_declarations_opt ::=
	|	SEMICOLON class_body_declarations_opt
	;
*/
parser Grm extends polyglot.parse.Grm  {:
  public final JL5TypeSystem ts;
  public final JL5NodeFactory nf;
  public long next_ordinal = 0;

  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
    super(l, t, n, q);
    ts = (JL5TypeSystem) t;
    nf = (JL5NodeFactory) n;
  }

    public ParamTypeNode toParamType(Position pos, Id id, List<TypeNode> bounds){
        return nf.ParamTypeNode(pos, id, CollectionUtil.nonNullList(bounds));
    }

    public List<LocalDecl> variableDeclarators(TypeNode a, List<VarDeclarator> b, Flags flags, List<AnnotationElem> annotations)
    throws Exception
    {
      List<LocalDecl> l = new LinkedList<>();
      for (VarDeclarator d : b) {
          l.add(nf.LocalDecl(pos(d), flags, annotations, array(a, d.dims),
                                  d.name, d.init));
      }
      return l;
   }


:};

// ellipsis token for varargs, new in Java 1.5 (JSR-201)
terminal Token ELLIPSIS;
// enum keyword, new in Java 1.5 (JSR-201)
terminal Token ENUM;

// annotation keyword
terminal Token AT;

non terminal Import static_single_type_import_declaration;
non terminal Import static_type_import_on_demand_declaration;

non terminal ClassBody class_body_opt;

// JSR-201) Enum Declaration
non terminal ClassDecl enum_declaration;
non terminal ClassBody enum_body;
non terminal List<ClassMember> enum_constants_opt;
non terminal List<ClassMember> enum_constants;
non terminal EnumConstantDecl enum_constant;
non terminal List<Expr> enum_arguments_opt;
non terminal List<ClassMember> enum_body_declarations_opt;
non terminal comma_opt;
// 19.11) Blocks and Statements
non terminal Loop foreach_statement, foreach_statement_no_short_if;
// 19.12) Expressions
non terminal NewArray initialized_array_creation_expression;//**

// JSR-14 2.1) Type Syntax 2.3) Handling Consecutive Type Brackets
non terminal TypeNode class_or_interface;
non terminal Name type_variable;
non terminal List<TypeNode> type_arguments, type_arguments_opt;
non terminal List<TypeNode> type_argument_list;
non terminal List<TypeNode> type_argument_list_1;
non terminal TypeNode reference_type_1;
non terminal List<TypeNode> type_argument_list_2;
non terminal TypeNode reference_type_2;
non terminal List<TypeNode> type_argument_list_3;
non terminal TypeNode reference_type_3;

// JSR-14 2.2) Parameterized Type Declarations 2.3) Handling Consecutive...
non terminal List<ParamTypeNode> type_parameters, type_parameters_opt;
non terminal ParamTypeNode type_parameter;
non terminal List<ParamTypeNode> type_parameter_list;
non terminal ParamTypeNode type_parameter_1;
non terminal List<ParamTypeNode> type_parameter_list_1;
non terminal List<TypeNode> type_bound, type_bound_opt;
non terminal List<TypeNode> type_bound_1;
non terminal List<TypeNode> additional_bound_list, additional_bound_list_opt;
non terminal List<TypeNode> additional_bound_list_1;
non terminal TypeNode additional_bound;
non terminal TypeNode additional_bound_1;
non terminal TypeNode wildcard, wildcard_1, wildcard_2, wildcard_3;
non terminal TypeNode type_argument, type_argument_1, type_argument_2, type_argument_3;
// not mentioned in JSR-14: need to reduce the precedence of instanceof
// Alternatively, you can tweak the relational_expression production a little.
non terminal Expr instanceof_expression;
//// expressions which are Not a Name
non terminal Expr postfix_expression_nn;
non terminal Expr unary_expression_nn;
non terminal Expr unary_expression_not_plus_minus_nn;
non terminal Expr multiplicative_expression_nn;
non terminal Expr additive_expression_nn;
non terminal Expr shift_expression_nn;
non terminal Expr relational_expression_nn;
non terminal Expr instanceof_expression_nn;
non terminal Expr equality_expression_nn;
non terminal Expr and_expression_nn;
non terminal Expr exclusive_or_expression_nn;
non terminal Expr inclusive_or_expression_nn;
non terminal Expr conditional_and_expression_nn;
non terminal Expr conditional_or_expression_nn;
non terminal Expr conditional_expression_nn;
non terminal Expr assignment_expression_nn;
non terminal Expr expression_nn;

// non terminals added for annotations
non terminal AnnotationElem annotation;
non terminal ClassBody annotation_body;
non terminal List<ClassMember> annotation_type_element_declarations_opt;
non terminal List<ClassMember> annotation_type_element_declarations;
non terminal List<ClassMember> annotation_type_element_declaration;
non terminal Term element_value; // Term
non terminal Term default_value_opt; // Term
non terminal ElementValuePair element_value_pair;
non terminal List<ElementValuePair> element_value_pairs, element_value_pairs_opt;
non terminal AnnotationElem marker_annotation, single_element_annotation, normal_annotation;
non terminal FlagAnnotations modifiers_or_annotations;
non terminal FlagAnnotations modifiers_or_annotations_opt;
non terminal ElementValueArrayInit element_value_array_initializer;
non terminal List<Term> element_values; // List

start with goal;

drop{modifiers}
drop{modifiers_opt}

override simple_name ::=
    IDENTIFIER:a
        {: RESULT = new JL5Name(parser.nf, parser.ts, parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
;

override qualified_name ::=
    name:a DOT IDENTIFIER:b
        {: RESULT = new JL5Name(parser.nf, parser.ts, parser.pos(a, b), a, parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
;

override identifier_opt ::=
    {: :}
    |
    IDENTIFIER:a
     {: RESULT = new JL5Name(parser.nf, parser.ts, parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
;

type_variable ::=
		IDENTIFIER:a
        {: RESULT = new Name(parser.nf, parser.ts, parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
	;
class_or_interface ::=
		name:a
        {: RESULT = a.toType(); :}
	|	class_or_interface:a LT type_argument_list_1:c DOT name:e
	   	 //Instantiating type arguments
        {: TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a, c);
           RESULT = ((JL5Name) e).toType(tn); :}
	;
override class_or_interface_type ::=
		class_or_interface:a
        {: RESULT = a; :}
	|	class_or_interface:a LT type_argument_list_1:c
   	 	// Instantiating type arguments
        {: RESULT = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a, c); :}
	;

extend array_type ::=
	// we have class_or_interface_type here even though only unbounded
	// wildcards are really allowed in the parameterization.
	// we have to expand this to avoid lookahead problems.
		class_or_interface:a LT type_argument_list_1:b DOT name:c dims:d
   	 	// Instantiating type arguments
        {: TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(a, b), a, b);
           TypeNode aa = ((JL5Name) c).toType(tn);
           RESULT = parser.array(aa, d.intValue()); :}
	|	class_or_interface:a LT type_argument_list_1:b dims:c
   	 	// Instantiating type arguments
        {:
            RESULT = parser.array(parser.nf.AmbTypeInstantiation(parser.pos(a, b), a, b), c.intValue()); :}
	;

//productions for type arguments have no semantic actions
type_arguments_opt ::=
    type_arguments:a
    {: RESULT = a; :}
    |
    {: :}

;

type_arguments ::=
		LT type_argument_list_1:a
        {: RESULT = a; :}
	;

wildcard ::=
    QUESTION:a
    {: RESULT = parser.nf.AmbWildCard(parser.pos(a)); :}
	|
    QUESTION:a EXTENDS reference_type:b
    {: RESULT = parser.nf.AmbWildCardExtends(parser.pos(a,b), b); :}
	|
    QUESTION:a SUPER reference_type:b
    {: RESULT = parser.nf.AmbWildCardSuper(parser.pos(a,b), b); :}
	;
wildcard_1 ::=
    QUESTION:a GT
    {: RESULT = parser.nf.AmbWildCard(parser.pos(a)); :}
	|
    QUESTION:a EXTENDS reference_type_1:b
    {: RESULT = parser.nf.AmbWildCardExtends(parser.pos(a,b), b); :}
	|
    QUESTION:a SUPER reference_type_1:b
    {: RESULT = parser.nf.AmbWildCardSuper(parser.pos(a,b), b); :}
	;
wildcard_2 ::=
    QUESTION:a RSHIFT
    {: RESULT = parser.nf.AmbWildCard(parser.pos(a)); :}
	|
    QUESTION:a EXTENDS reference_type_2:b
    {: RESULT = parser.nf.AmbWildCardExtends(parser.pos(a,b), b); :}
	|
    QUESTION:a SUPER reference_type_2:b
    {: RESULT = parser.nf.AmbWildCardSuper(parser.pos(a,b), b); :}
	;
wildcard_3 ::=
    QUESTION:a URSHIFT
    {: RESULT = parser.nf.AmbWildCard(parser.pos(a)); :}
	|
    QUESTION:a EXTENDS reference_type_3:b
    {: RESULT = parser.nf.AmbWildCardExtends(parser.pos(a,b), b); :}
	|
    QUESTION:a SUPER reference_type_3:b
    {: RESULT = parser.nf.AmbWildCardSuper(parser.pos(a,b), b); :}
	;
reference_type_1 ::=
		reference_type:a GT
        {: RESULT = a; :}
	|	class_or_interface:a LT type_argument_list_2:c
    // Instantiating type arguments
        {: RESULT = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a,c); :}
	;
reference_type_2 ::=
		reference_type:a RSHIFT
        {: RESULT = a; :}
	|	class_or_interface:a LT type_argument_list_3:c
    // Instantiating type arguments
        {: RESULT = parser.nf.AmbTypeInstantiation(parser.pos(a, c), a,c); :}
	;
reference_type_3 ::=
		reference_type:a URSHIFT
        {: RESULT = a; :}
	;
type_argument_list ::=
	type_argument:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
         :}
	|
    type_argument_list:a COMMA type_argument:b
        {: RESULT = a;
           a.add(b);
         :}
	;
type_argument_list_1 ::=
		type_argument_1:a
		{: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
         :}
	|	type_argument_list:a COMMA type_argument_1:b
	    {: RESULT = a;
	       a.add(b);
	     :}
	;
type_argument_list_2 ::=
		type_argument_2:a
	{: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
         :}
	|	type_argument_list:a COMMA type_argument_2:b
        {: RESULT = a;
           a.add(b);
         :}
	;
type_argument_list_3 ::=
		type_argument_3:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
         :}
	|	type_argument_list:a COMMA type_argument_3:b
        {: RESULT = a;
           a.add(b);
         :}
	;
type_argument ::=
		reference_type:a
        {: RESULT = a; :}
	|	wildcard:a
        {: RESULT = a; :}
	;
type_argument_1 ::=
		reference_type_1:a
        {: RESULT = a; :}
	|	wildcard_1:a
        {: RESULT = a; :}
	;
type_argument_2 ::=
		reference_type_2:a
        {: RESULT = a; :}
	|	wildcard_2:a
        {: RESULT = a; :}
	;
type_argument_3 ::=
		reference_type_3:a
        {: RESULT = a; :}
	|	wildcard_3:a
        {: RESULT = a; :}
	;

// 19.6) Packages
override package_declaration ::=
                    // PackageNode
        PACKAGE name:b SEMICOLON
            {: RESULT = b.toPackage(); :}
    /*|   annotations:a PACKAGE name:b SEMICOLON // XXX!@! ignoring annotations
            {: RESULT = b.toPackage(); :}
            */
    ;

extend import_declaration ::=
	static_single_type_import_declaration:a
        {: RESULT = a; :}
	|	static_type_import_on_demand_declaration:a
        {: RESULT = a; :}
	;
static_single_type_import_declaration ::=
		IMPORT:a STATIC name:c SEMICOLON:d
        {: RESULT = parser.nf.Import(parser.pos(a, d), JL5Import.SINGLE_STATIC_MEMBER, c.toString()); :}
	;
static_type_import_on_demand_declaration ::=
		IMPORT:a STATIC name:c DOT MULT SEMICOLON:d
        {: RESULT = parser.nf.Import(parser.pos(a, d), JL5Import.STATIC_ON_DEMAND, c.toString()); :}
	;
extend type_declaration ::=
    enum_declaration:a
        {: RESULT = a; :}
	;

override class_declaration ::=
                    // ClassDecl
        modifiers_or_annotations_opt:a CLASS:n IDENTIFIER:b type_parameters_opt:c
                superclass_opt:d interfaces_opt:e class_body:f
            {: RESULT = parser.nf.ClassDecl(parser.pos(n, e),
                a.flags(), a.annotations(), parser.nf.Id(parser.pos(b), b.getIdentifier()), d, e, f, c, parser.javadoc(a.position(), parser.pos(n))); :}
    ;
class_body_opt ::=
        {: :}
	|
    class_body:a
        {: RESULT = a; :}
;

drop { class_member_declaration ::= modifiers_opt CLASS IDENTIFIER superclass_opt interfaces_opt class_body; }

extend class_member_declaration ::=
    enum_declaration:a
    {: List<ClassMember> l = new LinkedList<>();
       l.add(a);
       RESULT = l; :}
 |  class_declaration:a
    {: List<ClassMember> l = new LinkedList<>();
       l.add(a);
       RESULT = l; :}
	;

// JSR-201) Enum Declaration
enum_declaration ::=
		modifiers_or_annotations_opt:a ENUM:b IDENTIFIER:c interfaces_opt:d enum_body:e
        {: RESULT = parser.nf.EnumDecl(
        		parser.pos(b, e), JL5Flags.setEnum(a.flags()), a.annotations(),
                 parser.nf.Id(parser.pos(c), c.getIdentifier()),
                 parser.nf.AmbTypeInstantiation(parser.pos(b, e),
                   parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Enum()),
                   Collections.<TypeNode>singletonList(
                     parser.nf.AmbTypeNode(parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())))),
                 d, e, parser.javadoc(a.position(), parser.pos(b))); :}
	;
enum_body ::=
		LBRACE:n enum_constants_opt:a enum_body_declarations_opt:b RBRACE:c
            {: a.addAll(b);
               RESULT = parser.nf.ClassBody(parser.pos(n, c), a); :}
	;
enum_constants_opt ::=
        {: RESULT = new LinkedList<>(); :}
	|	enum_constants:a comma_opt
        {: RESULT = a; :}
	;
enum_constants ::=
		enum_constant:a
        {: List<ClassMember> l = new LinkedList<>();
           parser.next_ordinal = 0;
           l.add(a.ordinal(parser.next_ordinal++));
           RESULT = l; :}
	|	enum_constants:a COMMA enum_constant:b
        {: List<ClassMember> l = a;
           a.add(b.ordinal(parser.next_ordinal++));
           RESULT = l; :}
	;
enum_constant ::=
		modifiers_or_annotations_opt:d IDENTIFIER:a enum_arguments_opt:b
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(a), d.flags(), d.annotations(), parser.nf.Id(parser.pos(a), a.getIdentifier()), parser.javadoc(d.position(), parser.pos(a)), b); :}
	|	modifiers_or_annotations_opt:d IDENTIFIER:a enum_arguments_opt:b class_body:c
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(a), d.flags(), d.annotations(), parser.nf.Id(parser.pos(a), a.getIdentifier()), b, c, parser.javadoc(d.position(), parser.pos(a))); :}
	;
enum_arguments_opt ::=
        {: RESULT = new LinkedList<>(); :}
	|	LPAREN argument_list_opt:a RPAREN
        {: RESULT = a; :}
	;
enum_body_declarations_opt ::=
        {: RESULT = new LinkedList<>(); :}
	|	SEMICOLON class_body_declarations_opt:a
        {: RESULT = a; :}
	;
comma_opt ::=
    |	COMMA
    ;

// 19.8.2) Field Declarations
override field_declaration ::=
    modifiers_or_annotations_opt:a type:b variable_declarators:c SEMICOLON:e
    {: List<ClassMember> l = new LinkedList<>();
       for (VarDeclarator d : c) {
         l.add(parser.nf.FieldDecl(parser.pos(b, e),
               a.flags(), a.annotations(), parser.array(b, d.dims),
               d.name, d.init, parser.javadoc(a.position(), parser.pos(b))));
        }
        RESULT = l; :}
    ;

// 19.8.3) Method Declarations
override method_header ::=
        // have to expand type_parameters_opt here so that we don't
        // force an early decision of whether this is a field_declaration
        // or a method_declaration (the type_parameters_opt would have to
        // be reduced when we see the 'type' if this was a method declaration,
        // but it might still turn out to be a field declaration).
        modifiers_or_annotations_opt:a type:b IDENTIFIER:d LPAREN
                formal_parameter_list_opt:e RPAREN dims_opt:g throws_opt:h
        {: RESULT = parser.nf.MethodDecl(parser.pos(b, g, d), a.flags(), a.annotations(), parser.array(b, g.intValue()), parser.nf.Id(parser.pos(d), d.getIdentifier()), e, h, null, new LinkedList<ParamTypeNode>(), parser.javadoc(a.position(), parser.pos(b))); :}
        |
    modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c type:d IDENTIFIER:i LPAREN
                formal_parameter_list_opt:e RPAREN dims_opt:g throws_opt:h
        {: RESULT = parser.nf.MethodDecl(parser.pos(d, g, i), a.flags(), a.annotations(), parser.array(d, g.intValue()), parser.nf.Id(parser.pos(i), i.getIdentifier()), e, h, null, c, parser.javadoc(a.position(), parser.pos(b))); :}
        |
    modifiers_or_annotations_opt:a VOID:b IDENTIFIER:c LPAREN
                formal_parameter_list_opt:e RPAREN:f throws_opt:h
        {: RESULT = parser.nf.MethodDecl(parser.pos(b, f, c), a.flags(), a.annotations(), parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), parser.nf.Id(parser.pos(c), c.getIdentifier()), e, h, null, new LinkedList<ParamTypeNode>(), parser.javadoc(a.position(), parser.pos(b))); :}
        |
    modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c VOID:d IDENTIFIER:i LPAREN
                formal_parameter_list_opt:e RPAREN:f throws_opt:h
        {: RESULT = parser.nf.MethodDecl(parser.pos(d, f, i), a.flags(), a.annotations(), parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), parser.nf.Id(parser.pos(i), i.getIdentifier()), e, h, null, c, parser.javadoc(a.position(), parser.pos(b))); :}
        ;
override formal_parameter ::=
                    // Formal
    modifiers_or_annotations_opt:a type:b variable_declarator_id:c
         {: RESULT = parser.nf.Formal(parser.pos(b, c, c), a.flags(), a.annotations(),
                     parser.array(b, c.dims), c.name); :}
    |
    // careful, productions below allow varargs in non-final positions.
    modifiers_or_annotations_opt:a type:b ELLIPSIS IDENTIFIER:d
        {:
           RESULT = parser.nf.Formal(parser.pos(b, d, d), a.flags(), a.annotations(), parser.nf.ArrayTypeNode(parser.pos(b), b), parser.nf.Id(parser.pos(d), d.getIdentifier()), true);
        :}
    ;

// 19.8.5) Constructor Declarations
override constructor_declaration ::=
        modifiers_or_annotations_opt:a  simple_name:d LPAREN formal_parameter_list_opt:e RPAREN  throws_opt:f constructor_body:g
        {: RESULT = parser.nf.ConstructorDecl(d.pos, a.flags(), a.annotations(), d.name, e, f, g, new LinkedList<ParamTypeNode>(), parser.javadoc(a.position(), parser.pos(d))); :}
        |
    modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c simple_name:d LPAREN formal_parameter_list_opt:e RPAREN throws_opt:f constructor_body:g
        {: RESULT = parser.nf.ConstructorDecl(d.pos, a.flags(), a.annotations(), d.name, e, f, g, c, parser.javadoc(a.position(), parser.pos(b))); :}
	;
extend explicit_constructor_invocation ::=
    //generic constructor invocations
		type_arguments:a THIS LPAREN argument_list_opt:d RPAREN SEMICOLON:f
        {: RESULT = parser.nf.ThisCall(parser.pos(a, f), a, d); :}
	|	type_arguments:a SUPER LPAREN argument_list_opt:d RPAREN SEMICOLON:f
        {: RESULT = parser.nf.SuperCall(parser.pos(a, f), a, d); :}
	|	primary:a DOT type_arguments:c SUPER:d
			LPAREN argument_list_opt:f RPAREN SEMICOLON:h
        {: RESULT = parser.nf.SuperCall(parser.pos(a, h, d), c, a, f); :}
	|	name:a DOT SUPER LPAREN:d argument_list_opt:e RPAREN SEMICOLON:g
        {: RESULT = parser.nf.SuperCall(parser.pos(a, g, d), a.toExpr(), e); :}
	|	name:a DOT type_arguments:c SUPER:d LPAREN argument_list_opt:f RPAREN SEMICOLON:h
        {: RESULT = parser.nf.SuperCall(parser.pos(a, h, d), c, a.toExpr(), f); :}

	|	name:a DOT THIS LPAREN:d argument_list_opt:e RPAREN SEMICOLON:g
        {: RESULT = parser.nf.ThisCall(parser.pos(a, g, d), a.toExpr(), e); :}
	|	primary:a DOT type_arguments:c THIS:d
			LPAREN argument_list_opt:f RPAREN SEMICOLON:h
        {: RESULT = parser.nf.ThisCall(parser.pos(a, h, d), c, a, f); :}
	|	name:a DOT type_arguments:c THIS:d LPAREN argument_list_opt:f RPAREN SEMICOLON:h
        {: RESULT = parser.nf.ThisCall(parser.pos(a, h, d), c, a.toExpr(), f); :}
	;

// 19.9) Interfaces

// 19.9.1) Interface Declarations
override interface_declaration ::=
		modifiers_or_annotations_opt:a INTERFACE:b IDENTIFIER:c type_parameters_opt:d extends_interfaces_opt:e interface_body:f
        {: FlagAnnotations n = a.setFlag(Flags.INTERFACE.position(b.getPosition()));
           RESULT = parser.nf.ClassDecl(parser.pos(b, f), n.flags(), a.annotations(), parser.nf.Id(parser.pos(c), c.getIdentifier()), null, e, f, d, parser.javadoc(a.position(), parser.pos(b))); :}
    | AT:a INTERFACE:b IDENTIFIER:c annotation_body:d
        {: List<TypeNode> superints = new LinkedList<>();
           Flags n = JL5Flags.ANNOTATION.position(a.getPosition());
           n = n.set(Flags.INTERFACE.position(b.getPosition()));
           superints.add(parser.nf.CanonicalTypeNode(parser.pos(b, d), parser.ts.Annotation()));
           RESULT = parser.nf.ClassDecl(parser.pos(a, d), n, null, parser.nf.Id(parser.pos(c), c.getIdentifier()), null, superints, d, null, parser.javadoc(parser.pos(a))); :}
    | modifiers_or_annotations:a AT:b INTERFACE:c IDENTIFIER:d annotation_body:e
        {: List<TypeNode> superints = new LinkedList<>();
           FlagAnnotations n = a.setFlag(JL5Flags.ANNOTATION.position(b.getPosition()));
           n = n.setFlag(Flags.INTERFACE.position(c.getPosition()));
           superints.add(parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Annotation()));
           RESULT = parser.nf.ClassDecl(parser.pos(b, d), n.flags(), a.annotations(), parser.nf.Id(parser.pos(d), d.getIdentifier()), null, superints, e, null, parser.javadoc(a.position())); :}
	;

extend interface_member_declaration ::=
	enum_declaration:a
        {: List<ClassMember> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	;


// 19.11) Blocks and Statements
extend block_statement ::=
	enum_declaration:a
        {: List<Stmt> l = new LinkedList<>();
           l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
           RESULT = l; :}
	;
override local_variable_declaration ::=
                    // List<LocalDecl>
    modifiers_or_annotations:a type:b variable_declarators:c
            {: RESULT = parser.variableDeclarators(b, c, a.flags(), a.annotations()); :}
    |
    type:a variable_declarators:b//**
            {: RESULT = parser.variableDeclarators(a, b, Flags.NONE); :}
	;
extend statement ::=
	foreach_statement:a
        {: RESULT = a; :}
	;
extend statement_no_short_if ::=
    foreach_statement_no_short_if:a
        {: RESULT = a; :}
	;
foreach_statement ::=//**
		FOR:a LPAREN type:c variable_declarator_id:d COLON expression:f RPAREN statement:h
 	       {:
 	       LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, c, d.name());
 	       RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h); :}
    |
        FOR:a LPAREN modifiers_or_annotations:c type:d variable_declarator_id:e COLON expression:g RPAREN statement:i
    	    {:
    	    LocalDecl ld = parser.nf.LocalDecl(parser.pos(d,e), c.flags(), c.annotations(), d, e.name(), null);
    	    RESULT = parser.nf.ExtendedFor(parser.pos(a, i), ld, g, i); :}
	;
foreach_statement_no_short_if ::=//**
		FOR:a LPAREN type:c variable_declarator_id:d COLON expression:f RPAREN statement_no_short_if:h
        	{:
        	LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, c, d.name(), null);
        	RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h); :}

	|	FOR:a LPAREN modifiers_or_annotations:c type:d variable_declarator_id:e COLON expression:g RPAREN statement_no_short_if:i
    		{:
       	    LocalDecl ld = parser.nf.LocalDecl(parser.pos(d,e), c.flags(), c.annotations(), d, e.name(), null);
    		RESULT = parser.nf.ExtendedFor(parser.pos(a, i), ld, g, i); :}
	;

// 19.12) Expressions
drop { primary_no_new_array ::=
		LPAREN expression RPAREN
	| array_type DOT CLASS
;}
extend primary_no_new_array ::=
		LPAREN name:a RPAREN
        {: RESULT = a.toExpr(); :}
	|	LPAREN expression_nn:a RPAREN
        {: RESULT = a; :}
	// "array_type DOT CLASS", but expanded
	|	primitive_type:a dims:b DOT CLASS:d
        {: RESULT = parser.nf.ClassLit(parser.pos(a, d, d), parser.array(a, b.intValue())); :}
	|	name:a dims:b DOT CLASS:d
        {: RESULT = parser.nf.ClassLit(parser.pos(a, d, d), parser.array(a.toType(), b.intValue())); :}
//	the following two productions are part of the expansion of
//	'type DOT CLASS' but are not actually allowed, as they involve params.
//	[see msg from Neal Gafter <3F219367.3070903@sun.com> 25-jul-2003]
//	|	class_or_interface type_arguments DOT name dims DOT CLASS
//	|	class_or_interface LT type_argument_list_1 dims DOT CLASS
	;
// grammar distributed with prototype 2.2 is in error; the following is correct
//  [ Neal Gafter, <3F2577E0.3090008@sun.com> ]
override class_instance_creation_expression ::=//**
		NEW:a class_or_interface_type:b LPAREN argument_list_opt:d RPAREN class_body_opt:f
        {: RESULT = parser.nf.New(parser.pos(a), b, d, f); :}
	|	NEW:a type_arguments:b class_or_interface_type:c LPAREN argument_list_opt:e RPAREN class_body_opt:g
	    // Instantiating type arguments
        {: RESULT = parser.nf.New(parser.pos(a), b, c, e, g); :}
	|	primary:a DOT NEW type_arguments_opt:d IDENTIFIER:e LPAREN argument_list_opt:h RPAREN class_body_opt:j
        // Instantiating type arguments
        {: TypeNode aa = (new JL5Name(parser.nf, parser.ts, parser.pos(e), parser.nf.Id(parser.pos(e), e.getIdentifier()))).toType();
           RESULT = parser.nf.New(parser.pos(a), a, d, aa, h, j); :}
	|	name:a DOT NEW type_arguments_opt:d IDENTIFIER:e LPAREN argument_list_opt:h RPAREN class_body_opt:j
	    // Instantiating type arguments
        {: TypeNode aa = (new JL5Name(parser.nf, parser.ts, parser.pos(e), parser.nf.Id(parser.pos(e), e.getIdentifier()))).toType();
           RESULT = parser.nf.New(parser.pos(a), a.toExpr(), d, aa, h, j); :}
	|	primary:a DOT NEW type_arguments_opt:d IDENTIFIER:e type_arguments:f LPAREN argument_list_opt:h RPAREN class_body_opt:j
        // Instantiating type arguments
        {: TypeNode aa = (new JL5Name(parser.nf, parser.ts, parser.pos(e), parser.nf.Id(parser.pos(e), e.getIdentifier()))).toType();
           TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(e, f), aa, f);
           RESULT = parser.nf.New(parser.pos(a), a, d, tn, h, j); :}
	|	name:a DOT NEW type_arguments_opt:d IDENTIFIER:e type_arguments:f LPAREN argument_list_opt:h RPAREN class_body_opt:j
	    // Instantiating type arguments
        {: TypeNode aa = (new JL5Name(parser.nf, parser.ts, parser.pos(e), parser.nf.Id(parser.pos(e), e.getIdentifier()))).toType();
           TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(e, f), aa, f);
           RESULT = parser.nf.New(parser.pos(a), a.toExpr(), d, tn, h, j); :}
;

override array_creation_expression ::= //**
                    // NewArray
        NEW:n primitive_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, b), a, b,
                c.intValue()); :}
    |   NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, b), a, b,
                c.intValue()); :}
	|  initialized_array_creation_expression:a
			{: RESULT = a; :}
	;

initialized_array_creation_expression ::=//**
		NEW:a primitive_type:b dims:c array_initializer:d
        {: RESULT = parser.nf.NewArray(parser.pos(a, d), b, Collections.<Expr> emptyList(), c.intValue(), d); :}
	|	NEW:a class_or_interface_type:b dims:c array_initializer:d
        {: RESULT = parser.nf.NewArray(parser.pos(a, d), b,
                Collections.<Expr> emptyList(), c.intValue(), d); :}
	;

override array_access ::=//**
              // ArrayAccess
    name:a LBRACK expression:b RBRACK:d
        {: RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a.toExpr(), b); :}
    |
    primary_no_new_array:a LBRACK expression:b RBRACK:d
        {: RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, b); :}
    |
	initialized_array_creation_expression:a LBRACK expression:c RBRACK:d
        {: RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, c); :}
	;

extend method_invocation ::=
// the following production appeared in the prototype 2.2 spec, but it
// introduces ambiguities in the grammar (consider the expression
//          A((B)<C,D>E());
// which could be either an invocation on E or two boolean comparisons).
// Neal Gafter has assured me that this production should be removed
// from the grammar. <3F256C06.7000600@sun.com>
//	|	type_arguments name LPAREN argument_list_opt RPAREN
	// Instantiating type arguments
    primary:a DOT type_arguments:c IDENTIFIER:d LPAREN argument_list_opt:f RPAREN:g
        {: RESULT = parser.nf.Call(parser.pos(a, g), a, c, parser.nf.Id(parser.pos(d), d.getIdentifier()), f); :}
	|
    name:a DOT type_arguments:c IDENTIFIER:d LPAREN argument_list_opt:f RPAREN:g
        {: RESULT = parser.nf.Call(parser.pos(a, g), a.toReceiver(), c, parser.nf.Id(parser.pos(d), d.getIdentifier()), f); :}
	|
    SUPER:a DOT type_arguments:c IDENTIFIER:d LPAREN argument_list_opt:f RPAREN:g
        {: RESULT = parser.nf.Call(parser.pos(a, g, d), parser.nf.Super(parser.pos(a)), c, parser.nf.Id(parser.pos(d), d.getIdentifier()), f); :}
    |
    name:a DOT SUPER:c DOT type_arguments:e IDENTIFIER:f LPAREN argument_list_opt:h RPAREN:i
        {: RESULT = parser.nf.Call(parser.pos(f, i), parser.nf.Super(parser.pos(c), a.toType()), e, parser.nf.Id(parser.pos(f), f.getIdentifier()), h); :}
	;

// This parsing technique was discovered by Eric Blake <ebb9@email.byu.edu>
// We solving grammar ambiguities with between parenthesized less-than
// relational operations and type casts with a slightly-more-complicated
// cast_expression production.
// Illustrative example:  LPAREN name LT name ...
//  is this going to be a cast_expression or a relational_expression?
// canonically, this production is:
//     cast_expression ::= LPAREN type RPAREN unary_expression_not_plus_minus
drop { cast_expression ::=
		LPAREN expression RPAREN unary_expression_not_plus_minus
;}
extend cast_expression ::=
		LPAREN:a name:b RPAREN unary_expression_not_plus_minus:d
        {: RESULT = parser.nf.Cast(parser.pos(a, d, b), b.toType(), d); :}
	|	LPAREN:a name:b LT type_argument_list_1:d dims_opt:e RPAREN
			unary_expression_not_plus_minus:g
        {:
          TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(b, d), b.toType(),d);
          RESULT = parser.nf.Cast(parser.pos(a, g, b), parser.array(tn, e.intValue()), g); :}
	|	LPAREN:a name:b LT type_argument_list_1:d DOT
			class_or_interface:f dims_opt:g RPAREN
			unary_expression_not_plus_minus:i//**
        {: AmbTypeNode bb = (AmbTypeNode)f;
           TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(b, d), parser.exprToType(b.toExpr()),d);
           RESULT = parser.nf.Cast(parser.pos(a, i, b), parser.array(parser.nf.AmbTypeNode(parser.pos(b, f), tn, bb.id()), g.intValue()), i); :}
	|	LPAREN:a name:b LT type_argument_list_1:d DOT
			class_or_interface:f LT type_argument_list_1:h dims_opt:j RPAREN
			unary_expression_not_plus_minus:i
        {: AmbTypeNode bb = (AmbTypeNode)f;
           TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(b, d), parser.exprToType(b.toExpr()), d);
           tn = parser.nf.AmbTypeInstantiation(parser.pos(b, h), parser.nf.AmbTypeNode(parser.pos(b, f), tn, bb.id()), h);
           RESULT = parser.nf.Cast(parser.pos(a, i, b), parser.array(tn, j.intValue()), i); :}
	;
drop { relational_expression ::=
		relational_expression INSTANCEOF reference_type
;}
// we lower the precendence of instanceof to resolve a grammar ambiguity.
// semantics are unchanged, since relational expressions do not operate
// on boolean.  Eric Blake had a different solution here, where he
// used the production 'shift_expression LT shift_expression' to solve
// the same problem.
instanceof_expression ::=
		relational_expression:a
        {: RESULT = a; :}
	|	instanceof_expression:a INSTANCEOF reference_type:c
        {: RESULT = parser.nf.Instanceof(parser.pos(a, c), a, c); :}
	;
override equality_expression ::=
		instanceof_expression:a
        {: RESULT = a; :}
	|	equality_expression:a EQEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.EQ, c); :}
	|	equality_expression:a NOTEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.NE, c); :}
	;
// 'constant_expression' should include enumerated constants.
// note that this constraint must be enforced during semantic checking

// JLS-14 productions.
type_parameters_opt ::=
    type_parameters:a
    {: RESULT = a; :}
    |
    {: RESULT = new LinkedList<>(); :}
;
type_parameters ::=
		LT type_parameter_list_1:a
        {: RESULT = a; :}
	;
type_parameter_list ::=
    type_parameter_list:a COMMA type_parameter:b
        {: a.add(b);
           RESULT = a; :}
	|
    type_parameter:a
        {: List<ParamTypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	;
type_parameter_list_1 ::=
    type_parameter_1:a
        {: List<ParamTypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	|
    type_parameter_list:a COMMA type_parameter_1:b
        {: a.add(b);
           RESULT = a; :}
	;
type_parameter ::=
		type_variable:a type_bound_opt:b
        {: RESULT = parser.toParamType(parser.pos(a, b), a.name, b); :}
	;
type_parameter_1 ::=
		type_variable:a GT
        {: RESULT = parser.toParamType(parser.pos(a), a.name, null); :}
	|	type_variable:a type_bound_1:b
        {: RESULT = parser.toParamType(parser.pos(a, b), a.name, b); :}
	;
type_bound_opt ::=
    type_bound:a
    {: RESULT = a; :}
    |
    {: :}
;
type_bound ::=
		EXTENDS reference_type:a additional_bound_list_opt:b
        {: if (b == null) {
                List<TypeNode> l = new LinkedList<>();
                l.add(a);
                RESULT = l;
           }
           else {
                b.add(0, a);
                RESULT = b;
           }:}
	;
type_bound_1 ::=
		EXTENDS reference_type_1:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	|	EXTENDS reference_type:a additional_bound_list_1:b
        {: b.add(0, a);
           RESULT = b; :}
	;
additional_bound_list_opt ::=
    additional_bound_list:a
    {: RESULT = a; :}
    |
    {: :}
;
additional_bound_list ::=
		additional_bound:a additional_bound_list:b
        {: b.add(0, a);
           RESULT = b; :}
	|	additional_bound:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	;
additional_bound_list_1 ::=
		additional_bound:a additional_bound_list_1:b
        {: b.add(0, a);
           RESULT = b; :}
	|	additional_bound_1:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	;
additional_bound ::=
		AND interface_type:a
        {: RESULT = a; :}
	;
additional_bound_1 ::=
		AND reference_type_1:a
        {: RESULT = a; :}
	;
//////////////////////////////////////////////
// the following productions are copied from the standard ones, but
// 'name' all alone is not allowed.  The '_nn' stands for 'not name'.
// we also expand the productions so that they recursively depend on the
// '_nn' forms of their left hand side, then adding a new production
// with 'name' explicit on the left-hand side.
// this allows us to postpone the decision whether '(x)' is an expression
// or a type-cast until we can see enough right context to make the proper
// choice.
postfix_expression_nn ::=
		primary:a
        {: RESULT = a; :}
	// the 'name' production was removed here.
	|	postincrement_expression:a
        {: RESULT = a; :}
	|	postdecrement_expression:a
        {: RESULT = a; :}
	;
unary_expression_nn ::=
		preincrement_expression:a
        {: RESULT = a; :}
	|	predecrement_expression:a
        {: RESULT = a; :}
	|	PLUS:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.POS, b); :}
	|	MINUS:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.NEG, b); :}
	|	MINUS:a boundary_literal:b
        {: RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.NEG, b); :}
	|	unary_expression_not_plus_minus_nn:a
        {: RESULT = a; :}
	;
unary_expression_not_plus_minus_nn ::=
		postfix_expression_nn:a
        {: RESULT = a; :}
	|	COMP:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a,b,b), Unary.BIT_NOT, b); :}
	|	NOT:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a,b,b), Unary.NOT, b); :}
	|	cast_expression:a
        {: RESULT = a; :}
	;
multiplicative_expression_nn ::=
		unary_expression_nn:a
        {: RESULT = a; :}
	|	name:a MULT unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.MUL, c); :}
	|	multiplicative_expression_nn:a MULT unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.MUL, c); :}
	|	name:a DIV unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.DIV, c); :}
	|	multiplicative_expression_nn:a DIV unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.DIV, c); :}
	|	name:a MOD unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.MOD, c); :}
	|	multiplicative_expression_nn:a MOD unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.MOD, c); :}
	;
additive_expression_nn ::=
		multiplicative_expression_nn:a
        {: RESULT = a; :}
	|	name:a PLUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.ADD, c); :}
	|	additive_expression_nn:a PLUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.ADD, c); :}
	|	name:a MINUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SUB, c); :}
	|	additive_expression_nn:a MINUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SUB, c); :}
	;
shift_expression_nn ::=
		additive_expression_nn:a
        {: RESULT = a; :}
	|	name:a LSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SHL, c); :}
	|	shift_expression_nn:a LSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SHL, c); :}
	|	name:a RSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SHR, c); :}
	|	shift_expression_nn:a RSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SHR, c); :}
	|	name:a URSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.USHR, c); :}
	|	shift_expression_nn:a URSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.USHR, c); :}
	;
relational_expression_nn ::=
		shift_expression_nn:a
        {: RESULT = a; :}
	// note that we've tweaked the productions for LT/GT to disallow
	//  a<b<c as a valid expression.  This avoids ambiguity with
	//  parameterized types in casts.
	|	name:a LT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.LT, c); :}
	|	shift_expression_nn:a LT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LT, c); :}
	|	name:a GT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GT, c); :}
	|	shift_expression_nn:a GT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GT, c); :}
	|	name:a LTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.LE, c); :}
	|	relational_expression_nn:a LTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LE, c); :}
	|	name:a GTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GE, c); :}
	|	relational_expression_nn:a GTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GE, c); :}
	;
instanceof_expression_nn ::=
		relational_expression_nn:a
        {: RESULT = a; :}
	|	name:a INSTANCEOF reference_type:c
        {: RESULT = parser.nf.Instanceof(parser.pos(a, c), a.toExpr(), c); :}
	|	instanceof_expression_nn:a INSTANCEOF reference_type:c
        {: RESULT = parser.nf.Instanceof(parser.pos(a, c), a, c); :}
	;
equality_expression_nn ::=
		instanceof_expression_nn:a
        {: RESULT = a; :}
	|	name:a EQEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.EQ, c); :}
	|	equality_expression_nn:a EQEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.EQ, c); :}
	|	name:a NOTEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.NE, c); :}
	|	equality_expression_nn:a NOTEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.NE, c); :}
	;
and_expression_nn ::=
		equality_expression_nn:a
        {: RESULT = a; :}
	|	name:a AND equality_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_AND, c); :}
	|	and_expression_nn:a AND equality_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_AND, c); :}
	;
exclusive_or_expression_nn ::=
		and_expression_nn:a
        {: RESULT = a; :}
	|	name:a XOR and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_XOR, c); :}
	|	exclusive_or_expression_nn:a XOR and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_XOR, c); :}
	;
inclusive_or_expression_nn ::=
		exclusive_or_expression_nn:a
        {: RESULT = a; :}
	|	name:a OR exclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_OR, c); :}
	|	inclusive_or_expression_nn:a OR exclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_OR, c); :}
	;
conditional_and_expression_nn ::=
		inclusive_or_expression_nn:a
        {: RESULT = a; :}
	|	name:a ANDAND inclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.COND_AND, c); :}
	|	conditional_and_expression_nn:a ANDAND inclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.COND_AND, c); :}
	;
conditional_or_expression_nn ::=
		conditional_and_expression_nn:a
        {: RESULT = a; :}
	|	name:a OROR conditional_and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.COND_OR, c); :}
	|	conditional_or_expression_nn:a OROR conditional_and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.COND_OR, c); :}
	;

conditional_expression_nn ::=
		conditional_or_expression_nn:a
        {: RESULT = a; :}
	|	name:a QUESTION expression:c COLON conditional_expression:e
        {: RESULT = parser.nf.Conditional(parser.pos(a, e), a.toExpr(), c, e); :}
	|	conditional_or_expression_nn:a QUESTION expression:c
			COLON conditional_expression:e
        {: RESULT = parser.nf.Conditional(parser.pos(a, e), a, c, e); :}

	;

assignment_expression_nn ::=
		conditional_expression_nn:a
        {: RESULT = a; :}
	|	assignment:a
        {: RESULT = a; :}
	;
expression_nn ::=	assignment_expression_nn:a
    {: RESULT = a; :}
	;

// START productions for annotations
//    These productions have no semantic actions, so the
//    value of any annotation nonterminal will be null

modifiers_or_annotations_opt ::=
    /* empty */
       {: FlagAnnotations fl = new FlagAnnotations(parser.emptyTokenPos());
           RESULT = fl; :}
    |
    modifiers_or_annotations:a
        {: RESULT = a; :}
;

modifiers_or_annotations ::=
    modifier:a
        {: FlagAnnotations fl = new FlagAnnotations(parser.emptyTokenPos());
           RESULT = fl.flags(a);
        :}
    |
    annotation:a
        {: FlagAnnotations fl = new FlagAnnotations(parser.emptyTokenPos());
           RESULT = fl.addAnnotation(a);
        :}
    |
    modifiers_or_annotations:a modifier:b
        {:
           if (a.flags().intersects(b)) parser.die(parser.position());
           RESULT = a.flags(a.flags().set(b));
        :}
    |
    modifiers_or_annotations:a annotation:b
        {:
          RESULT = a.addAnnotation(b);
        :}
;


annotation ::=
    normal_annotation:a
        {: RESULT = a; :}
    |
    marker_annotation:a
        {: RESULT = a; :}
    |
    single_element_annotation:a
        {: RESULT = a; :}
;


marker_annotation ::=
    AT:a name:b
        {: RESULT = parser.nf.MarkerAnnotationElem(parser.pos(a, b), b.toType()); :}
;

single_element_annotation ::=
    AT:a name:b LPAREN element_value:c RPAREN
       {: RESULT = parser.nf.SingleElementAnnotationElem(parser.pos(a, b), b.toType(), c); :}
;

normal_annotation ::=
    AT:a name:b LPAREN element_value_pairs_opt:c RPAREN
        {:RESULT = parser.nf.NormalAnnotationElem(parser.pos(a, b), b.toType(), c); :}
;

element_value_pairs_opt ::=
        {: RESULT = new LinkedList<>(); :}
    |
    element_value_pairs:a
        {: RESULT = a; :}
;

element_value_pairs ::=
    element_value_pair:a
        {: List<ElementValuePair> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
        :}
    |
    element_value_pairs:a COMMA element_value_pair:b
        {: a.add(b);
           RESULT = a; :}
;
element_value_pair ::=
    IDENTIFIER:a EQ element_value:b
    {: RESULT = parser.nf.ElementValuePair(parser.pos(a,b), parser.nf.Id(parser.pos(a), a.getIdentifier()), b); :}
;

annotation_body ::=
    LBRACE:n annotation_type_element_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.ClassBody(parser.pos(n,d), a); :}
;

annotation_type_element_declarations_opt ::=
        {: RESULT = new LinkedList<>(); :}
    |
    annotation_type_element_declarations:a
        {: RESULT = a; :}
;

annotation_type_element_declarations ::=
    annotation_type_element_declaration:a
        {: RESULT = a; :}
    |
    annotation_type_element_declarations:a annotation_type_element_declaration:b
        {: RESULT = a;
           a.addAll(b); :}
;
annotation_type_element_declaration ::=
    modifiers_or_annotations_opt:a type:b IDENTIFIER:c LPAREN RPAREN default_value_opt:d SEMICOLON
        {: List<ClassMember> l = new LinkedList<>();
           l.add(parser.nf.AnnotationElemDecl(parser.pos(b,d), a.flags(), parser.array(b, 0), parser.nf.Id(parser.pos(c), c.getIdentifier()), d, parser.javadoc(a.position(), parser.pos(b))));
           RESULT = l; :}
    | constant_declaration:a
        {: RESULT = a; :}
    | class_declaration:a
        {: List<ClassMember> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
    | interface_declaration:a
        {: List<ClassMember> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
    | enum_declaration:a
        {: List<ClassMember> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
    | SEMICOLON
        {: RESULT = Collections.<ClassMember> emptyList(); :}
;

default_value_opt ::=
        {: :}
    |
    DEFAULT element_value:a
        {: RESULT = a; :}
;


element_values ::=
    element_value:a
        {: List<Term> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
        :}
    |
    element_values:a COMMA element_value:b
        {: a.add(b);
           RESULT = a;
        :}
;

element_value_array_initializer ::=
    LBRACE:n element_values:a COMMA RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n element_values:a RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n COMMA RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d)); :}
    |
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d)); :}
;

element_value ::=
    /* should be element value array initializer */
    element_value_array_initializer:a
        {: RESULT = a; :}
    |
    conditional_expression:a
        {: RESULT = a; :}
    /* or annotation */
    |
    annotation:a
        {: RESULT = a; :}
;

// END productions for annotations
