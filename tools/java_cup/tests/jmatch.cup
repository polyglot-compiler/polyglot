package polyglot.ext.jmatch.parse;

import java.util.*;
import java_cup.runtime.*;
import polyglot.ast.*;
import polyglot.lex.*;
import polyglot.util.*;
import polyglot.parse.*;
import polyglot.types.*;
import polyglot.*;
import polyglot.ast.Assert;
import polyglot.util.*;
import polyglot.ext.jmatch.ast.*;
import polyglot.ext.jmatch.types.*;
import polyglot.ext.jmatch.extension.*;
import polyglot.ext.jmatch.parse.Name;

parser Grm extends polyglot.parse.BaseParser {:


  public Grm( Lexer l, JMatchTypeSystem t, JMatchNodeFactory n,
      ErrorQueue q ) {
    super(l,t,n,q);
  }

  public void syntax_error( Symbol current ) {
    Position p = ((Token)current.value).getPosition();

    if ( current.sym == sym.EOF ) {
      report_error( "Unexpected end of file.", p );
    } else {
      report_error( "Syntax error.", p );
    }
  }

  public void report_error( String message, Object info ) {
    if ( info instanceof Position ) {
      eq.enqueue( ErrorInfo.SYNTAX_ERROR, message, (Position)info );
    } else {
      eq.enqueue( ErrorInfo.SYNTAX_ERROR, message );
    }
  }

  public JMatchNodeFactory jmnf() {
    return (JMatchNodeFactory)nf;
  }

  public Multiplicity singular() {
    return ((JMatchTypeSystem)ts).Singular();
  }

  public Multiplicity multiple() {
    return ((JMatchTypeSystem)ts).Multiple();
  }

  static class Declarator {
    Position pos;
    String name;
    int dims;
    Expr init;

    Declarator( Position pos, String name ) {
      this.pos = pos;
      this.name = name;
      this.dims = 0;
      this.init = null;
    }
  }

  protected Position posForObject(Object o) {
      if (o instanceof Name) {
          return pos ((Name) o);
      }
      return super.posForObject(o);
  }

  public static Position pos( Name n ) {
    return n == null ? null : n.pos;
  }

  public static Position pos( Declarator d ) {
    return d == null ? null : d.pos;
  }

  public Position pos() {
    return new Position( lexer.file() );
  }

  /**
   * Replaces all extension nodes in the subtree rooted at t with copies of
   * ext.
   **/
  public AmbTypeNode replaceExts( AmbTypeNode t, JMatch ext ) {
    AmbQualifierNode qual = (AmbQualifierNode)t.qual();
    t = (AmbTypeNode)t.ext( (JMatch)ext.copy() );

    if ( qual == null ) {
      return t;
    }
    return (AmbTypeNode)t.qual( replaceExts(qual, ext) );
  }

  /**
   * Replaces all extension nodes in the subtree rooted at q with copies of
   * ext.
   **/
  public AmbQualifierNode replaceExts( AmbQualifierNode q, JMatch ext ) {
    Position pos = q.position();
    AmbQualifierNode qual = (AmbQualifierNode)q.qual();
    String name = q.name();

    AmbQualifierNode result = q;

    if ( qual != null ) {
      result = nf.AmbQualifierNode( pos, replaceExts(qual, ext), name );
    }

    return (AmbQualifierNode)result.ext( (JMatch)ext.copy() );
  }

:}
scan with {: return nextSymbol(); :};
terminal Token BOOLEAN;
terminal Token BYTE, SHORT, INT, LONG, CHAR;
terminal Token FLOAT, DOUBLE;
terminal Token LBRACK, RBRACK;
terminal Identifier IDENTIFIER;
terminal Token DOT;
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ;
terminal Token LPAREN, RPAREN, COLON;
terminal Token PACKAGE;
terminal Token IMPORT;
terminal Token PUBLIC, PROTECTED, PRIVATE;
terminal Token STATIC;
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS;
terminal Token EXTENDS;
terminal Token IMPLEMENTS;
terminal Token VOID;
terminal Token THROWS;
terminal Token THIS, SUPER;
terminal Token INTERFACE;
terminal Token IF, ELSE;
terminal Token SWITCH;
terminal Token CASE, DEFAULT;
terminal Token DO, WHILE;
terminal Token FOR;
terminal Token BREAK;
terminal Token CONTINUE;
terminal Token RETURN;
terminal Token THROW;
terminal Token TRY;
terminal Token CATCH;
terminal Token FINALLY;
terminal Token NEW;
terminal Token PLUSPLUS;
terminal Token MINUSMINUS;
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT;
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF;
terminal Token EQEQ, NOTEQ;
terminal Token AND;
terminal Token XOR;
terminal Token OR;
terminal Token ANDAND;
terminal Token OROR;
terminal Token QUESTION;
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ;
terminal Token ANDEQ, XOREQ, OREQ;
terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL;
terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL_BD;
terminal polyglot.lex.LongLiteral LONG_LITERAL;
terminal polyglot.lex.LongLiteral LONG_LITERAL_BD;
terminal polyglot.lex.DoubleLiteral DOUBLE_LITERAL;
terminal polyglot.lex.FloatLiteral FLOAT_LITERAL;
terminal polyglot.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal polyglot.lex.CharacterLiteral CHARACTER_LITERAL;
terminal polyglot.lex.StringLiteral STRING_LITERAL;
terminal polyglot.lex.NullLiteral NULL_LITERAL;
terminal Token STRICTFP;
terminal Token ASSERT;
terminal CONST, GOTO;
non terminal SourceFile goal;
non terminal polyglot.ast.Lit literal;
non terminal polyglot.ast.Lit boundary_literal;
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode class_type, interface_type;
non terminal TypeNode array_type;
non terminal Name name, simple_name, qualified_name;
non terminal SourceFile compilation_unit;
non terminal PackageNode package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal Import import_declaration;
non terminal Import single_type_import_declaration;
non terminal Import type_import_on_demand_declaration;
non terminal ClassDecl type_declaration;
non terminal Flags modifiers_opt, modifiers, modifier;
non terminal ClassDecl class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal ClassBody class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal List class_body_declaration, class_member_declaration;
non terminal List field_declaration;
non terminal List variable_declarators;


non terminal Expr variable_initializer;

non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal Formal formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;

non terminal Block static_initializer;



non terminal ClassDecl interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal ClassBody interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal List interface_member_declaration;
non terminal List constant_declaration;

non terminal ArrayInit array_initializer;
non terminal List variable_initializers;
non terminal Block block;
non terminal List block_statements_opt, block_statements;
non terminal List block_statement;


non terminal Stmt statement, statement_no_short_if;
non terminal Stmt statement_without_trailing_substatement;
non terminal Empty empty_statement;
non terminal Labeled labeled_statement, labeled_statement_no_short_if;
non terminal Stmt expression_statement;
non terminal Expr statement_expression;
non terminal If if_then_statement;
non terminal If if_then_else_statement, if_then_else_statement_no_short_if;

non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;

non terminal While while_statement, while_statement_no_short_if;
non terminal Do do_statement;
non terminal For for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal Name identifier_opt;
non terminal Branch break_statement, continue_statement;
non terminal Return return_statement;
non terminal Throw throw_statement;
non terminal Synchronized synchronized_statement;
non terminal Try try_statement;
non terminal List catches_opt, catches;
non terminal Catch catch_clause;
non terminal Block finally;
non terminal Assert assert_statement;
non terminal Expr primary, primary_no_new_array;
non terminal Expr class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal NewArray array_creation_expression;
non terminal List dim_exprs;
non terminal Expr dim_expr;
non terminal Integer dims_opt, dims;
non terminal Field field_access;

non terminal ArrayAccess array_access;
non terminal Expr postfix_expression;
non terminal Unary postincrement_expression, postdecrement_expression;
non terminal Expr unary_expression, unary_expression_not_plus_minus;
non terminal Unary preincrement_expression, predecrement_expression;
non terminal Cast cast_expression;
non terminal Expr multiplicative_expression, additive_expression;
non terminal Expr shift_expression, relational_expression;
non terminal Expr and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expr conditional_and_expression, conditional_or_expression;
non terminal Expr conditional_expression, assignment_expression;
non terminal Expr assignment;
non terminal Expr left_hand_side;
non terminal Assign.Operator assignment_operator;
non terminal Expr expression_opt, expression;

terminal Token AS;
terminal Token COND;
terminal Token CUT;
terminal Token EXISTS;
terminal Token FORALL;
terminal Token FOREACH;
terminal Token LET;
terminal Token ITERATE;
terminal Token ITERATES;
terminal Token RESUME;
terminal Token RETURNS;
terminal Token TRAP;
terminal Token TRAPS;
terminal Token UNDERSCORE;
terminal Token WHERE;
terminal Token WITH;
terminal Token YIELD;
non terminal Grm.Declarator variable_declarator, variable_declarator_id;
non terminal JMatchSwitch switch_statement;
non terminal JMatchCase switch_label;
non terminal Expr method_invocation;
non terminal Expr instanceof_expression;
non terminal Iterate iterate_expression;
non terminal PredConstructorDecl predicate_constructor_declaration;
non terminal List predicate_constructor_implementations;
non terminal PredDecl predicate_declaration;
non terminal PredDecl abstract_predicate_declaration;
non terminal PredDecl predicate_header;
non terminal List catches_no_semi;
non terminal Trap trap_clause;
non terminal List default_trap_clause;
non terminal List traps_opt;
non terminal List predicate_body;
non terminal List predicate_body_;
non terminal List predicate_implementations;
non terminal List default_predicate_implementation_opt;
non terminal List default_predicate_implementation;
non terminal List abstract_predicate_modes;
non terminal List predicate_modes;
non terminal List predicate_mode_list;
non terminal List unknown_lists;
non terminal Object[] unknown_list;
non terminal Object[] non_empty_unknown_list;
non terminal Expr predicate_fmla_impl_body;
non terminal Block predicate_iter_impl_body;
non terminal Foreach foreach_statement;
non terminal Foreach foreach_statement_no_short_if;
non terminal Let let_statement;
non terminal Cond cond_statement;
non terminal List conditions;
non terminal List expression_list;
non terminal List case_list;
non terminal Receiver case;
non terminal Yield yield_statement;
non terminal Resume resume_statement;
non terminal List trap_clauses_opt;
non terminal List trap_clauses_or_semi;
non terminal List trap_clauses;
non terminal List trap_clauses_no_semi;
non terminal Node with_clause;
non terminal Expr formula;
terminal STMT;

precedence nonassoc STMT;
precedence nonassoc ELSE;

start with goal;

goal ::=
    compilation_unit:a {:
                       if (parser.eq.hasErrors()) RESULT = null;
               else RESULT = a;
                       :};

literal ::=
    INTEGER_LITERAL:a {:
                      RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue());
                      :}
 |  LONG_LITERAL:a {:
                   RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                     a.getValue().longValue());
                   :}
 |  DOUBLE_LITERAL:a {:
                     RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.DOUBLE,
                                           a.getValue().doubleValue());
                     :}
 |  FLOAT_LITERAL:a {:
                    RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.FLOAT,
                                           a.getValue().floatValue());
                    :}
 |  BOOLEAN_LITERAL:a {:
                      RESULT = parser.nf.BooleanLit(parser.pos(a),
                                         a.getValue().booleanValue());
                      :}
 |  CHARACTER_LITERAL:a {:
                        RESULT = parser.nf.CharLit(parser.pos(a),
                      a.getValue().charValue());
                        :}
 |  STRING_LITERAL:a {:
                     RESULT = parser.nf.StringLit(parser.pos(a), a.getValue());
                     :}
 |  NULL_LITERAL:a {:  RESULT = parser.nf.NullLit(parser.pos(a));  :};

boundary_literal ::=
    INTEGER_LITERAL_BD:a {:
                         RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue());
                         :}
 |  LONG_LITERAL_BD:a {:
                      RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                     a.getValue().longValue());
                      :};

type ::=
    primitive_type:a {:  RESULT = a;  :}
 |  reference_type:a {:  RESULT = a;  :};

primitive_type ::=
    numeric_type:a {:  RESULT = a;  :}
 |  BOOLEAN:a {:
              RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean());
              :};

numeric_type ::=
    integral_type:a {:  RESULT = a;  :}
 |  floating_point_type:a {:  RESULT = a;  :};

integral_type ::=
    BYTE:a {:
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Byte());
           :}
 |  CHAR:a {:
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Char());
           :}
 |  SHORT:a {:
            RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Short());
            :}
 |  INT:a {:
          RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Int());
          :}
 |  LONG:a {:
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Long());
           :};

floating_point_type ::=
    FLOAT:a {:
            RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Float());
            :}
 |  DOUBLE:a {:
             RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Double());
             :};

reference_type ::=
    class_or_interface_type:a {:  RESULT = a;  :}
 |  array_type:a {:  RESULT = a;  :};

class_or_interface_type ::=
    name:a {:  RESULT = a.toType();  :};

class_type ::=
    class_or_interface_type:a {:  RESULT = a;  :};

interface_type ::=
    class_or_interface_type:a {:  RESULT = a;  :};

array_type ::=
    primitive_type:a dims:b {:  RESULT = parser.array(a, b.intValue());  :}
 |  name:a dims:b {:  RESULT = parser.array(a.toType(), b.intValue());  :};

name ::=
    simple_name:a {:  RESULT = a;  :}
 |  qualified_name:a {:  RESULT = a;  :};

simple_name ::=
    IDENTIFIER:a {:
                 RESULT = new Name(parser, parser.pos(a), a.getIdentifier());
                 :};

qualified_name ::=
    name:a DOT IDENTIFIER:b {:
                            RESULT = new Name(parser, parser.pos(a, b), a, b.getIdentifier());
                            :};

compilation_unit ::=
    package_declaration_opt:a import_declarations_opt:b type_declarations_opt:c {:
                                                                                RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()),
					     a, b, c);

                                                                                :}
 |  error type_declarations_opt:c {:
                                  RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()),
					     null, Collections.EMPTY_LIST, c);

                                  :};

package_declaration_opt ::=
    package_declaration:a {:  RESULT = a;  :}
 |  {:  RESULT = null;  :};

import_declarations_opt ::=
    import_declarations:a {:  RESULT = a;  :}
 |  {:  RESULT = new TypedList(new LinkedList(), Import.class, false);  :};

type_declarations_opt ::=
    type_declarations:a {:  RESULT = a;  :}
 |  {:
    RESULT = new TypedList(new LinkedList(), TopLevelDecl.class, false);
    :};

import_declarations ::=
    import_declaration:a {:
                         List l = new TypedList(new LinkedList(), Import.class, false);
               l.add(a);
               RESULT = l;
                         :}
 |  import_declarations:a import_declaration:b {:
                                               RESULT = a;
               a.add(b);
                                               :};

type_declarations ::=
    type_declaration:a {:
                       List l = new TypedList(new LinkedList(), TopLevelDecl.class, false);
               if (a != null)
                   l.add(a);
               RESULT = l;
                       :}
 |  type_declarations:a type_declaration:b {:
                                           RESULT = a;
               if (b != null)
                   a.add(b);
                                           :};

package_declaration ::=
    PACKAGE name:a SEMICOLON {:  RESULT = a.toPackage();  :};

import_declaration ::=
    single_type_import_declaration:a {:  RESULT = a;  :}
 |  type_import_on_demand_declaration:a {:  RESULT = a;  :};

single_type_import_declaration ::=
    IMPORT:a qualified_name:b SEMICOLON:c {:
                                          RESULT = parser.nf.Import(parser.pos(a, c), Import.CLASS, b.toString());
                                          :};

type_import_on_demand_declaration ::=
    IMPORT:a name:b DOT MULT SEMICOLON:c {:
                                         RESULT = parser.nf.Import(parser.pos(a, c), Import.PACKAGE, b.toString());
                                         :};

type_declaration ::=
    class_declaration:a {:  RESULT = a;  :}
 |  interface_declaration:a {:  RESULT = a;  :}
 |  SEMICOLON {:  RESULT = null;  :};

modifiers_opt ::=
    {:  RESULT = Flags.NONE;  :}
 |  modifiers:a {:  RESULT = a;  :};

modifiers ::=
    modifier:a {:  RESULT = a;  :}
 |  modifiers:a modifier:b {:
                           if (a.intersects(b)) parser.die(parser.position());
               RESULT = a.set(b);
                           :};

modifier ::=
    PUBLIC:a {:  RESULT = Flags.PUBLIC;  :}
 |  PROTECTED:a {:  RESULT = Flags.PROTECTED;  :}
 |  PRIVATE:a {:  RESULT = Flags.PRIVATE;  :}
 |  STATIC:a {:  RESULT = Flags.STATIC;  :}
 |  ABSTRACT:a {:  RESULT = Flags.ABSTRACT;  :}
 |  FINAL:a {:  RESULT = Flags.FINAL;  :}
 |  NATIVE:a {:  RESULT = Flags.NATIVE;  :}
 |  SYNCHRONIZED:a {:  RESULT = Flags.SYNCHRONIZED;  :}
 |  TRANSIENT:a {:  RESULT = Flags.TRANSIENT;  :}
 |  VOLATILE:a {:  RESULT = Flags.VOLATILE;  :}
 |  STRICTFP:a {:  RESULT = Flags.STRICTFP;  :};

class_declaration ::=
    modifiers_opt:a CLASS:n IDENTIFIER:b super_opt:c interfaces_opt:d class_body:e {:
                                                                                   RESULT = parser.nf.ClassDecl(parser.pos(n, e),
                a, b.getIdentifier(), c, d, e);
                                                                                   :};

super ::=
    EXTENDS class_type:a {:  RESULT = a;  :};

super_opt ::=

 |  super:a {:  RESULT = a;  :};

interfaces ::=
    IMPLEMENTS interface_type_list:a {:  RESULT = a;  :};

interfaces_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), TypeNode.class, false);  :}
 |  interfaces:a {:  RESULT = a;  :};

interface_type_list ::=
    interface_type:a {:
                     List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l;
                     :}
 |  interface_type_list:a COMMA interface_type:b {:
                                                 RESULT = a;
               a.add(b);
                                                 :};

class_body ::=
    LBRACE:n class_body_declarations_opt:a RBRACE:b {:
                                                    RESULT = parser.nf.ClassBody(parser.pos(n, b), a);
                                                    :};

class_body_declarations_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), ClassMember.class, false);  :}
 |  class_body_declarations:a {:  RESULT = a;  :};

class_body_declarations ::=
    class_body_declaration:a {:  RESULT = a;  :}
 |  class_body_declarations:a class_body_declaration:b {:
                                                       RESULT = a;
               a.addAll(b);
                                                       :};

class_body_declaration ::=
    class_member_declaration:a {:  RESULT = a;  :}
 |  static_initializer:a {:
                         List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.STATIC, a));
               RESULT = l;
                         :}
 |  block:a {:
            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.NONE, a));
               RESULT = l;
            :}
 |  SEMICOLON {:
              List l = new TypedList(new LinkedList(), ClassMember.class, false);
               RESULT = l;
              :}
 |  error SEMICOLON:a {:
                      List l = new TypedList(new LinkedList(), ClassMember.class, false);
               RESULT = l;
                      :}
 |  error LBRACE:a {:
                   List l = new TypedList(new LinkedList(), ClassMember.class, false);
               RESULT = l;
                   :}
 |  predicate_constructor_declaration:a {:

      List l = new TypedList( new LinkedList(), ClassMember.class, false );
      l.add(a);
      RESULT = l;

                                        :};

class_member_declaration ::=
    field_declaration:a {:  RESULT = a;  :}
 |  modifiers_opt:a CLASS:n IDENTIFIER:b super_opt:c interfaces_opt:d class_body:e {:
                                                                                   List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.ClassDecl(parser.pos(n, e),
                        a, b.getIdentifier(), c, d, e));
               RESULT = l;
                                                                                   :}
 |  interface_declaration:a {:
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l;
                            :}
 |  predicate_declaration:a {:

      List l = new TypedList( new LinkedList(), ClassMember.class, false );
      l.add(a);
      RESULT = l;

                            :};

field_declaration ::=
    modifiers_opt:a type:b variable_declarators:c SEMICOLON {:

      List l = new TypedList( new LinkedList(), ClassMember.class, false );
      for ( Iterator it = c.iterator(); it.hasNext(); ) {
        Grm.Declarator d = (Grm.Declarator)it.next();
	l.add( parser.nf.FieldDecl( parser.pos(b), a, parser.array(b, d.dims),
	    d.name, d.init ) );
      }

      RESULT = l;

                                                            :};

variable_declarators ::=
    variable_declarators:a COMMA variable_declarator:b {:
                                                       RESULT = a;
               a.add(b);
                                                       :}
 |  variable_declarator:a {:

      List l = new TypedList( new LinkedList(), Grm.Declarator.class, false );
      l.add(a);
      RESULT = l;

                          :};

variable_initializer ::=
    expression:a {:  RESULT = a;  :}
 |  array_initializer:a {:  RESULT = a;  :};

formal_parameter_list_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), Formal.class, false);  :}
 |  formal_parameter_list:a {:  RESULT = a;  :};

formal_parameter_list ::=
    formal_parameter:a {:
                       List l = new TypedList(new LinkedList(), Formal.class, false);
               l.add(a);
               RESULT = l;
                       :}
 |  formal_parameter_list:a COMMA formal_parameter:b {:
                                                     RESULT = a;
               a.add(b);
                                                     :};

formal_parameter ::=
    type:a variable_declarator_id:b {:
                                    RESULT = parser.nf.Formal(parser.pos(a, b, b), Flags.NONE,
                                         parser.array(a, b.dims), b.name);
                                    :}
 |  FINAL type:a variable_declarator_id:b {:
                                          RESULT = parser.nf.Formal(parser.pos(a, b, b), Flags.FINAL,
                     parser.array(a, b.dims), b.name);
                                          :};

throws_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), TypeNode.class, false);  :}
 |  throws:a {:  RESULT = a;  :};

throws ::=
    THROWS class_type_list:a {:  RESULT = a;  :};

class_type_list ::=
    class_type:a {:
                 List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l;
                 :}
 |  class_type_list:a COMMA class_type:b {:
                                         RESULT = a;
               a.add(b);
                                         :};

static_initializer ::=
    STATIC block:a {:  RESULT = a;  :};

interface_declaration ::=
    modifiers_opt:a INTERFACE:n IDENTIFIER:b extends_interfaces_opt:c interface_body:d {:
                                                                                       RESULT = parser.nf.ClassDecl(
                    parser.pos(n, d), a.Interface(),
                        b.getIdentifier(), null, c, d);
                                                                                       :};

extends_interfaces_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), TypeNode.class, false);  :}
 |  extends_interfaces:a {:  RESULT = a;  :};

extends_interfaces ::=
    EXTENDS interface_type:a {:
                             List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l;
                             :}
 |  extends_interfaces:a COMMA interface_type:b {:
                                                RESULT = a;
               a.add(b);
                                                :};

interface_body ::=
    LBRACE:n interface_member_declarations_opt:a RBRACE:d {:
                                                          RESULT = parser.nf.ClassBody(parser.pos(n, d), a);
                                                          :};

interface_member_declarations_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), ClassMember.class, false);  :}
 |  interface_member_declarations:a {:  RESULT = a;  :};

interface_member_declarations ::=
    interface_member_declaration:a {:  RESULT = a;  :}
 |  interface_member_declarations:a interface_member_declaration:b {:
                                                                   RESULT = a;
               a.addAll(b);
                                                                   :};

interface_member_declaration ::=
    constant_declaration:a {:  RESULT = a;  :}
 |  class_declaration:a {:
                        List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l;
                        :}
 |  interface_declaration:a {:
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l;
                            :}
 |  SEMICOLON {:  RESULT = Collections.EMPTY_LIST;  :}
 |  abstract_predicate_declaration:a {:

      List l = new TypedList( new LinkedList(), ClassMember.class, false );
      l.add(a);
      RESULT = l;

                                     :};

constant_declaration ::=
    field_declaration:a {:  RESULT = a;  :};

array_initializer ::=
    LBRACE:n variable_initializers:a COMMA RBRACE:d {:
                                                    RESULT = parser.nf.ArrayInit(parser.pos(n, d), a);
                                                    :}
 |  LBRACE:n variable_initializers:a RBRACE:d {:
                                              RESULT = parser.nf.ArrayInit(parser.pos(n, d), a);
                                              :}
 |  LBRACE:n COMMA RBRACE:d {:
                            RESULT = parser.nf.ArrayInit(parser.pos(n, d));
                            :}
 |  LBRACE:n RBRACE:d {:  RESULT = parser.nf.ArrayInit(parser.pos(n, d));  :};

variable_initializers ::=
    variable_initializer:a {:
                           List l = new TypedList(new LinkedList(), Expr.class, false);
           l.add(a);
           RESULT = l;
                           :}
 |  variable_initializers:a COMMA variable_initializer:b {:
                                                         RESULT = a; a.add(b);
                                                         :};

block ::=
    LBRACE:n block_statements_opt:a RBRACE:d {:
                                             RESULT = parser.nf.Block(parser.pos(n, d), a);
                                             :}
 |  error RBRACE:d {:
                   RESULT = parser.nf.Block(parser.pos(d),
                                        Collections.EMPTY_LIST);
                   :};

block_statements_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), Stmt.class, false);  :}
 |  block_statements:a {:  RESULT = a;  :};

block_statements ::=
    block_statement:a {:
                      List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               RESULT = l;
                      :}
 |  block_statements:a block_statement:b {:
                                         RESULT = a;
               a.addAll(b);
                                         :};

block_statement ::=
    statement:a {:
                List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               RESULT = l;
                :}
 |  class_declaration:a {:
                        List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
               RESULT = l;
                        :};

statement ::=
    statement_without_trailing_substatement:a {:  RESULT = a;  :}
 |  labeled_statement:a {:  RESULT = a;  :}
 |  if_then_statement:a {:  RESULT = a;  :}
 |  if_then_else_statement:a {:  RESULT = a;  :}
 |  while_statement:a {:  RESULT = a;  :}
 |  for_statement:a {:  RESULT = a;  :}
 |  error SEMICOLON:a {:  RESULT = parser.nf.Empty(parser.pos(a));  :}
 |  foreach_statement:a {:
      RESULT = a;
     :}
 |  resume_statement:a {:
      RESULT = a;
     :};

statement_no_short_if ::=
    statement_without_trailing_substatement:a {:  RESULT = a;  :}
 |  labeled_statement_no_short_if:a {:  RESULT = a;  :}
 |  if_then_else_statement_no_short_if:a {:  RESULT = a;  :}
 |  while_statement_no_short_if:a {:  RESULT = a;  :}
 |  for_statement_no_short_if:a {:  RESULT = a;  :}
 |  foreach_statement_no_short_if:a {:
      RESULT = a;
     :};

statement_without_trailing_substatement ::=
    block:a {:  RESULT = a;  :}
 |  empty_statement:a {:  RESULT = a;  :}
 |  expression_statement:a {:  RESULT = a;  :}
 |  switch_statement:a {:  RESULT = a;  :}
 |  do_statement:a {:  RESULT = a;  :}
 |  break_statement:a {:  RESULT = a;  :}
 |  continue_statement:a {:  RESULT = a;  :}
 |  return_statement:a {:  RESULT = a;  :}
 |  synchronized_statement:a {:  RESULT = a;  :}
 |  throw_statement:a {:  RESULT = a;  :}
 |  try_statement:a {:  RESULT = a;  :}
 |  assert_statement:a {:  RESULT = a;  :}
 |  let_statement:a {:
      RESULT = a;
     :}
 |  cond_statement:a {:
      RESULT = a;
     :}
 |  yield_statement:a {:
      RESULT = a;
     :};

empty_statement ::=
    SEMICOLON:a {:  RESULT = parser.nf.Empty(parser.pos(a));  :};

labeled_statement ::=
    IDENTIFIER:a COLON statement:b {:
                                   RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b);
                                   :};

labeled_statement_no_short_if ::=
    IDENTIFIER:a COLON statement_no_short_if:b {:
                                               RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b);
                                               :};

expression_statement ::=
    statement_expression:a SEMICOLON:d {:
                                       RESULT = parser.nf.Eval(parser.pos(a, d), a);
                                       :};

statement_expression ::=
    relational_expression:a {:
      RESULT = a;
     :}
 |  assignment:a {:
      RESULT = a;
     :};

if_then_statement ::=
    IF:n LPAREN expression:a RPAREN statement:b {:
                                                RESULT = parser.nf.If(parser.pos(n, b), a, b);
                                                :};

if_then_else_statement ::=
    IF:n LPAREN expression:a RPAREN statement_no_short_if:b ELSE statement:c {:
                                                                             RESULT = parser.nf.If(parser.pos(n, c), a, b, c);
                                                                             :};

if_then_else_statement_no_short_if ::=
    IF:n LPAREN expression:a RPAREN statement_no_short_if:b ELSE statement_no_short_if:c {:
                                                                                         RESULT = parser.nf.If(parser.pos(n, c), a, b, c);
                                                                                         :};

switch_block ::=
    LBRACE switch_block_statement_groups:a switch_labels:b RBRACE {:
                                                                  RESULT = a;
               a.addAll(b);
                                                                  :}
 |  LBRACE switch_block_statement_groups:a RBRACE {:  RESULT = a;  :}
 |  LBRACE switch_labels:a RBRACE {:  RESULT = a;  :}
 |  LBRACE RBRACE {:

      RESULT =
	new TypedList( new LinkedList(), JMatchSwitchElement.class, false );

                  :};

switch_block_statement_groups ::=
    switch_block_statement_group:a {:  RESULT = a;  :}
 |  switch_block_statement_groups:a switch_block_statement_group:b {:
                                                                   RESULT = a;
               a.addAll(b);
                                                                   :};

switch_block_statement_group ::=
    switch_labels:a block_statements:b {:

      List l =
	new TypedList( new LinkedList(), JMatchSwitchElement.class, false );
      l.addAll(a);
      l.add( parser.nf.SwitchBlock( parser.pos(a), b ) );
      RESULT = l;

                                       :};

switch_labels ::=
    switch_labels:a switch_label:b {:  RESULT = a;
               a.add(b);  :}
 |  switch_label:a {:

      List l = new TypedList( new LinkedList(), JMatchCase.class, false );
      l.add(a);
      RESULT = l;

                   :};

while_statement ::=
    WHILE:n LPAREN expression:a RPAREN statement:b {:
                                                   RESULT = parser.nf.While(parser.pos(n, b), a, b);
                                                   :};

while_statement_no_short_if ::=
    WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b {:
                                                               RESULT = parser.nf.While(parser.pos(n, b), a, b);
                                                               :};

do_statement ::=
    DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON:d {:
                                                                  RESULT = parser.nf.Do(parser.pos(n, d), a, b);
                                                                  :};

for_statement ::=
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e for_update_opt:c RPAREN statement:d {:
                                                                                                           RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d);
                                                                                                           :};

for_statement_no_short_if ::=
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e for_update_opt:c RPAREN statement_no_short_if:d {:
                                                                                                                       RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d);
                                                                                                                       :};

for_init_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), ForInit.class, false);  :}
 |  for_init:a {:  RESULT = a;  :};

for_init ::=
    statement_expression_list:a {:  RESULT = a;  :};

for_update_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), ForUpdate.class, false);  :}
 |  for_update:a {:  RESULT = a;  :};

for_update ::=
    statement_expression_list:a {:  RESULT = a;  :};

statement_expression_list ::=
    statement_expression:a {:
                           List l = new TypedList(new LinkedList(), Eval.class, false);
               l.add(parser.nf.Eval(parser.pos(a), a));
               RESULT = l;
                           :}
 |  statement_expression_list:a COMMA statement_expression:b {:
                                                             RESULT = a;
               a.add(parser.nf.Eval(parser.pos(a, b, b), b));
                                                             :};

identifier_opt ::=
    {:  RESULT = null;  :}
 |  IDENTIFIER:a {:
                 RESULT = new Name(parser, parser.pos(a),
                a.getIdentifier());
                 :};

break_statement ::=
    BREAK:n identifier_opt:a SEMICOLON:d {:
                                         if (a == null)
                   RESULT = parser.nf.Break(parser.pos(n, d));
               else
                   RESULT = parser.nf.Break(parser.pos(n, d), a.toString());
                                         :};

continue_statement ::=
    CONTINUE:n identifier_opt:a SEMICOLON:d {:
                                            if (a == null)
                   RESULT = parser.nf.Continue(parser.pos(n, d));
               else
                   RESULT = parser.nf.Continue(parser.pos(n, d), a.toString());
                                            :};

return_statement ::=
    RETURN:n expression_opt:a SEMICOLON:d {:
                                          RESULT = parser.nf.Return(parser.pos(n, d), a);
                                          :};

throw_statement ::=
    THROW:n expression:a SEMICOLON:d {:
                                     RESULT = parser.nf.Throw(parser.pos(n, d), a);
                                     :};

synchronized_statement ::=
    SYNCHRONIZED:n LPAREN expression:a RPAREN block:b {:
                                                      RESULT = parser.nf.Synchronized(parser.pos(n, b), a, b);
                                                      :};

try_statement ::=
    TRY:n block:a catches:b {:
                            RESULT = parser.nf.Try(parser.pos(n, b), a, b);
                            :}
 |  TRY:n block:a catches_opt:b finally:c {:
                                          RESULT = parser.nf.Try(parser.pos(n, c), a, b, c);
                                          :};

catches_opt ::=
    {:

      RESULT = new TypedList(new LinkedList(), Catch.class, false);

    :}
 |  catches_no_semi:a {:
      RESULT = a;
     :};

catches ::=
    catch_clause:a {:

      List l = new TypedList(new LinkedList(), Catch.class, false);
      l.add(a);
      RESULT = l;

                   :} trap_clause:a {:

      List l = new TypedList(new LinkedList(), Catch.class, false);
      l.add(a);
      RESULT = l;

                                    :}
 |  default_trap_clause:a SEMICOLON {:

      List l = new TypedList(new LinkedList(), Catch.class, false);
      l.addAll(a);
      RESULT = l;

                                    :}
 |  catches_no_semi:a catch_clause:b {:

      RESULT = a;
      a.add(b);

                                     :}
 |  catches_no_semi:a trap_clause:b {:

      RESULT = a;
      a.add(b);

                                    :}
 |  catches_no_semi:a default_trap_clause:b SEMICOLON {:

      RESULT = a;
      a.add(b);

                                                      :};

catch_clause ::=
    CATCH:n LPAREN formal_parameter:a RPAREN block:b {:
                                                     RESULT = parser.nf.Catch(parser.pos(n, b), a, b);
                                                     :}
 |  CATCH:n LPAREN type:a RPAREN block:b {:

      RESULT =
	parser.nf.Catch(parser.pos(n),
	  parser.nf.Formal(parser.pos(a), Flags.NONE, parser.array(a, 0),
	    UniqueID.newID("t")), b);

                                         :};

finally ::=
    FINALLY block:a {:  RESULT = a;  :};

assert_statement ::=
    ASSERT:x expression:a SEMICOLON:d {:
                                      RESULT = parser.nf.Assert(parser.pos(x, d), a);
                                      :}
 |  ASSERT:x expression:a COLON expression:b SEMICOLON:d {:
                                                         RESULT = parser.nf.Assert(parser.pos(x, d), a, b);
                                                         :};

primary ::=
    primary_no_new_array:a {:  RESULT = a;  :}
 |  array_creation_expression:a {:  RESULT = a;  :};

primary_no_new_array ::=
    literal:a {:  RESULT = a;  :}
 |  THIS:a {:  RESULT = parser.nf.This(parser.pos(a));  :}
 |  LPAREN expression:a RPAREN {:  RESULT = a;  :}
 |  class_instance_creation_expression:a {:  RESULT = a;  :}
 |  field_access:a {:  RESULT = a;  :}
 |  method_invocation:a {:  RESULT = a;  :}
 |  array_access:a {:  RESULT = a;  :}
 |  primitive_type:a DOT CLASS:n {:
                                 RESULT = parser.nf.ClassLit(parser.pos(a, n, n), a);
                                 :}
 |  VOID:a DOT CLASS:n {:
                       RESULT = parser.nf.ClassLit(parser.pos(a, n, n),
                parser.nf.CanonicalTypeNode(parser.pos(a),
                                            parser.ts.Void()));
                       :}
 |  array_type:a DOT CLASS:n {:
                             RESULT = parser.nf.ClassLit(parser.pos(a, n, n), a);
                             :}
 |  name:a DOT CLASS:n {:
                       RESULT = parser.nf.ClassLit(parser.pos(a, n, n), a.toType());
                       :}
 |  name:a DOT THIS:n {:
                      RESULT = parser.nf.This(parser.pos(a, n, n), a.toType());
                      :}
 |  iterate_expression:a {:
      RESULT = a;
     :};

class_instance_creation_expression ::=
    NEW:n class_type:a LPAREN argument_list_opt:b RPAREN:d {:
                                                           RESULT = parser.nf.New(parser.pos(n, d), a, b);
                                                           :}
 |  NEW:n class_type:a LPAREN argument_list_opt:b RPAREN class_body:c {:
                                                                      RESULT = parser.nf.New(parser.pos(n, c), a, b, c);
                                                                      :}
 |  primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                        RESULT = parser.nf.New(parser.pos(a, d), a,
				      b.toType(), c);
                                                                        :}
 |  primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d {:
                                                                                   RESULT = parser.nf.New(parser.pos(a, d), a,
				      b.toType(), c, d);
                                                                                   :}
 |  name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                     RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(),
				      b.toType(), c);
                                                                     :}
 |  name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d {:
                                                                                RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(),
				      b.toType(), c, d);
                                                                                :};

argument_list_opt ::=
    {:  RESULT = new TypedList(new LinkedList(), Expr.class, false);  :}
 |  argument_list:a {:  RESULT = a;  :};

argument_list ::=
    expression:a {:
                 List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l;
                 :}
 |  argument_list:a COMMA expression:b {:
                                       RESULT = a;
               a.add(b);
                                       :};

array_creation_expression ::=
    NEW:n primitive_type:a dim_exprs:b dims_opt:c {:
                                                  RESULT = parser.nf.NewArray(parser.pos(n, b), a, b,
                c.intValue());
                                                  :}
 |  NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c {:
                                                           RESULT = parser.nf.NewArray(parser.pos(n, b), a, b,
                c.intValue());
                                                           :}
 |  NEW:n primitive_type:a dims:b array_initializer:c {:
                                                      RESULT = parser.nf.NewArray(parser.pos(n, c), a,
                b.intValue(), c);
                                                      :}
 |  NEW:n class_or_interface_type:a dims:b array_initializer:c {:
                                                               RESULT = parser.nf.NewArray(parser.pos(n, c), a,
                b.intValue(), c);
                                                               :};

dim_exprs ::=
    dim_expr:a {:
               List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l;
               :}
 |  dim_exprs:a dim_expr:b {:  RESULT = a;
               a.add(b);  :};

dim_expr ::=
    LBRACK:x expression:a RBRACK:y {:
                                   RESULT = (Expr)a.position(parser.pos(x,y,a));
                                   :};

dims_opt ::=
    {:  RESULT = 0;  :}
 |  dims:a {:  RESULT = a;  :};

dims ::=
    LBRACK RBRACK {:  RESULT = 1;  :}
 |  dims:a LBRACK RBRACK {:  RESULT = a + 1;  :};

field_access ::=
    primary:a DOT IDENTIFIER:b {:
                               RESULT = parser.nf.Field(parser.pos(a, b, b), a,
                b.getIdentifier());
                               :}
 |  SUPER:n DOT IDENTIFIER:a {:
                             RESULT = parser.nf.Field(parser.pos(a),
                parser.nf.Super(parser.pos(n)),
                a.getIdentifier());
                             :}
 |  name:a DOT SUPER:n DOT IDENTIFIER:b {:
                                        RESULT = parser.nf.Field(parser.pos(b),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier());
                                        :};

array_access ::=
    name:a LBRACK expression:b RBRACK:d {:
                                        RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a.toExpr(), b);
                                        :}
 |  primary_no_new_array:a LBRACK expression:b RBRACK:d {:
                                                        RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, b);
                                                        :};

postfix_expression ::=
    primary:a {:  RESULT = a;  :}
 |  postincrement_expression:a {:  RESULT = a;  :}
 |  postdecrement_expression:a {:  RESULT = a;  :}
 |  name:a {:
	RESULT = a.toAmbExpr();
     :}
 |  type:a variable_declarator_id:b {:

      RESULT =
	parser.jmnf().FreeVarDecl( parser.pos(a), Flags.NONE,
	  parser.array(a, b.dims), b.name );

                                    :}
 |  FINAL type:a variable_declarator_id:b {:

      RESULT =
	parser.jmnf().FreeVarDecl( parser.pos(a), Flags.FINAL,
	  parser.array(a, b.dims), b.name );

                                          :}
 |  CUT:a LPAREN expression:b RPAREN {:

      RESULT = parser.jmnf().Cut( parser.pos(a), b );

                                     :}
 |  UNDERSCORE:a {:

      RESULT = parser.jmnf().Wildcard( parser.pos(a) );

                 :}
 |  FORALL:a LPAREN formula:b RPAREN LBRACE formula:c RBRACE {:

      RESULT = parser.jmnf().Forall( parser.pos(a), b, c );

                                                             :}
 |  EXISTS:a LPAREN formula:b RPAREN LBRACE formula:c RBRACE {:

      RESULT = parser.jmnf().Exists( parser.pos(a), b, c );

                                                             :}
 |  TRY:n LPAREN formula:a RPAREN catches_no_semi:b {:

      RESULT = parser.jmnf().TryFmla(parser.pos(n), a, b);

                                                    :};

postincrement_expression ::=
    postfix_expression:a PLUSPLUS:b {:
                                    RESULT = parser.nf.Unary(parser.pos(a,b), a, Unary.POST_INC);
                                    :};

postdecrement_expression ::=
    postfix_expression:a MINUSMINUS:b {:
                                      RESULT = parser.nf.Unary(parser.pos(a,b), a, Unary.POST_DEC);
                                      :};

unary_expression ::=
    preincrement_expression:a {:  RESULT = a;  :}
 |  predecrement_expression:a {:  RESULT = a;  :}
 |  PLUS:b unary_expression:a {:
                              RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.POS, a);
                              :}
 |  MINUS:b unary_expression:a {:
                               RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NEG, a);
                               :}
 |  MINUS:b boundary_literal:a {:
                               RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NEG, a);
                               :}
 |  unary_expression_not_plus_minus:a {:  RESULT = a;  :};

preincrement_expression ::=
    PLUSPLUS:b unary_expression:a {:
                                  RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.PRE_INC, a);
                                  :};

predecrement_expression ::=
    MINUSMINUS:b unary_expression:a {:
                                    RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.PRE_DEC, a);
                                    :};

unary_expression_not_plus_minus ::=
    postfix_expression:a {:  RESULT = a;  :}
 |  COMP:b unary_expression:a {:
                              RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.BIT_NOT, a);
                              :}
 |  NOT:b unary_expression:a {:
                             RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NOT, a);
                             :}
 |  cast_expression:a {:  RESULT = a;  :};

cast_expression ::=
    LPAREN:p primitive_type:a dims_opt:b RPAREN unary_expression:c {:
                                                                   RESULT = parser.nf.Cast(parser.pos(p, c,a),
                parser.array(a, b.intValue()), c);
                                                                   :}
 |  LPAREN:p expression:a RPAREN unary_expression_not_plus_minus:b {:
                                                                   RESULT = parser.nf.Cast(parser.pos(p, b,a),
                parser.exprToType(a), b);
                                                                   :}
 |  LPAREN:p name:a dims:b RPAREN unary_expression_not_plus_minus:c {:
                                                                    RESULT = parser.nf.Cast(parser.pos(p, c,a),
                parser.array(a.toType(), b.intValue()), c);
                                                                    :};

multiplicative_expression ::=
    unary_expression:a {:  RESULT = a;  :}
 |  multiplicative_expression:a MULT unary_expression:b {:
                                                        RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.MUL, b);
                                                        :}
 |  multiplicative_expression:a DIV unary_expression:b {:
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.DIV, b);
                                                       :}
 |  multiplicative_expression:a MOD unary_expression:b {:
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.MOD, b);
                                                       :};

additive_expression ::=
    multiplicative_expression:a {:  RESULT = a;  :}
 |  additive_expression:a PLUS multiplicative_expression:b {:
                                                           RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.ADD, b);
                                                           :}
 |  additive_expression:a MINUS multiplicative_expression:b {:
                                                            RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.SUB, b);
                                                            :};

shift_expression ::=
    additive_expression:a {:  RESULT = a;  :}
 |  shift_expression:a LSHIFT additive_expression:b {:
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.SHL, b);
                                                    :}
 |  shift_expression:a RSHIFT additive_expression:b {:
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.SHR, b);
                                                    :}
 |  shift_expression:a URSHIFT additive_expression:b {:
                                                     RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.USHR, b);
                                                     :};

relational_expression ::=
    instanceof_expression:a {:
      RESULT = a;
     :}
 |  instanceof_expression:a LT relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.LT, b );

                                                       :}
 |  instanceof_expression:a GT relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.GT, b );

                                                       :}
 |  instanceof_expression:a LTEQ relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.LE, b );

                                                         :}
 |  instanceof_expression:a GTEQ relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.GE, b );

                                                         :}
 |  instanceof_expression:a EQEQ relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.EQ, b );

                                                         :}
 |  instanceof_expression:a NOTEQ relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.NE, b );

                                                          :}
 |  instanceof_expression:a EQ relational_expression:b {:

      RESULT = parser.nf.Assign( parser.pos(a), a, Assign.ASSIGN, b );

                                                       :}
 |  instanceof_expression:a EQ array_initializer:b {:

      RESULT = parser.nf.Assign( parser.pos(a), a, Assign.ASSIGN, b );

                                                   :};

and_expression ::=
    relational_expression:a {:
      RESULT = a;
     :}
 |  and_expression:a AND relational_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, Binary.BIT_AND, b );

                                                 :};

exclusive_or_expression ::=
    and_expression:a {:  RESULT = a;  :}
 |  exclusive_or_expression:a XOR and_expression:b {:
                                                   RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.BIT_XOR, b);
                                                   :};

inclusive_or_expression ::=
    exclusive_or_expression:a {:  RESULT = a;  :}
 |  inclusive_or_expression:a OR exclusive_or_expression:b {:
                                                           RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.BIT_OR, b);
                                                           :};

conditional_and_expression ::=
    inclusive_or_expression:a {:  RESULT = a;  :}
 |  conditional_and_expression:a ANDAND inclusive_or_expression:b {:
                                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.COND_AND, b);
                                                                  :};

conditional_or_expression ::=
    conditional_and_expression:a {:  RESULT = a;  :}
 |  conditional_or_expression:a OROR conditional_and_expression:b {:
                                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a,
                Binary.COND_OR, b);
                                                                  :}
 |  conditional_or_expression:a ELSE conditional_and_expression:b {:

      RESULT = parser.nf.Binary( parser.pos(a), a, JMatchBinary.ELSE, b );

                                                                  :};

conditional_expression ::=
    conditional_or_expression:a {:  RESULT = a;  :}
 |  conditional_or_expression:a QUESTION expression:b COLON conditional_expression:c {:
                                                                                     RESULT = parser.nf.Conditional(parser.pos(a, c), a,
                b, c);
                                                                                     :};

assignment_expression ::=
    conditional_expression:a {:  RESULT = a;  :}
 |  assignment:a {:  RESULT = a;  :};

assignment ::=
    left_hand_side:a assignment_operator:b assignment_expression:c {:
                                                                   RESULT = parser.nf.Assign(parser.pos(a, c), a, b, c);
                                                                   :};

left_hand_side ::=
    name:a {:  RESULT = a.toExpr();  :}
 |  field_access:a {:  RESULT = a;  :}
 |  array_access:a {:  RESULT = a;  :};

assignment_operator ::=
    MULTEQ {:  RESULT = Assign.MUL_ASSIGN;  :}
 |  DIVEQ {:  RESULT = Assign.DIV_ASSIGN;  :}
 |  MODEQ {:  RESULT = Assign.MOD_ASSIGN;  :}
 |  PLUSEQ {:  RESULT = Assign.ADD_ASSIGN;  :}
 |  MINUSEQ {:  RESULT = Assign.SUB_ASSIGN;  :}
 |  LSHIFTEQ {:  RESULT = Assign.SHL_ASSIGN;  :}
 |  RSHIFTEQ {:  RESULT = Assign.SHR_ASSIGN;  :}
 |  URSHIFTEQ {:  RESULT = Assign.USHR_ASSIGN;  :}
 |  ANDEQ {:  RESULT = Assign.BIT_AND_ASSIGN;  :}
 |  XOREQ {:  RESULT = Assign.BIT_XOR_ASSIGN;  :}
 |  OREQ {:  RESULT = Assign.BIT_OR_ASSIGN;  :};

expression_opt ::=
    {:  RESULT = null;  :}
 |  expression:a {:  RESULT = a;  :};

expression ::=
    assignment_expression:a {:  RESULT = a;  :};

instanceof_expression ::=
    shift_expression:a {:  RESULT = a;  :}
 |  instanceof_expression:a INSTANCEOF reference_type:b {:

      RESULT = parser.nf.Instanceof( parser.pos(a), a, b );

                                                        :}
 |  instanceof_expression:a AS shift_expression:b {:

      RESULT = parser.jmnf().As( parser.pos(a), a, b );

                                                  :};

switch_statement ::=
    SWITCH:n LPAREN expression_list:a RPAREN switch_block:b {:

      RESULT = parser.jmnf().Switch( parser.pos(n), a, b );

                                                            :};

switch_label ::=
    CASE:n case_list:a COLON {:

      RESULT = parser.jmnf().JMatchCase( parser.pos(n), a );

                             :}
 |  DEFAULT:n COLON {:

      RESULT = parser.jmnf().JMatchDefault( parser.pos(n) );

                    :}
 |  CASE:n case_list:a WHERE formula:b COLON {:

      RESULT = parser.jmnf().JMatchCase( parser.pos(n), a, b );

                                             :};

variable_declarator ::=
    variable_declarator_id:a {:
      RESULT = a;
     :}
 |  variable_declarator_id:a EQ variable_initializer:b {:

      RESULT = a;
      a.init = b;

                                                       :};

variable_declarator_id ::=
    IDENTIFIER:a {:

      RESULT = new Grm.Declarator( parser.pos(a), a.getIdentifier() );

                 :}
 |  variable_declarator_id:a LBRACK RBRACK {:

      a.dims++;
      RESULT = a;

                                           :};

catches_no_semi ::=
    catch_clause:a {:

      List l = new TypedList(new LinkedList(), Catch.class, false);
      l.add(a);
      RESULT = l;

                   :} trap_clause:a {:

      List l = new TypedList(new LinkedList(), Catch.class, false);
      l.add(a);
      RESULT = l;

                                    :}
 |  default_trap_clause:a {:

      List l = new TypedList(new LinkedList(), Catch.class, false);
      l.addAll(a);
      RESULT = l;

                          :}
 |  catches_no_semi:a catch_clause:b {:

      RESULT = a;
      a.add(b);

                                     :}
 |  catches_no_semi:a trap_clause:b {:

      RESULT = a;
      a.add(b);

                                    :}
 |  catches_no_semi:a default_trap_clause:b {:

      RESULT = a;
      a.add(b);

                                            :};

trap_clause ::=
    TRAP:n LPAREN type:a RPAREN block:b {:

      RESULT =
	parser.jmnf().Trap(parser.pos(n),
	  parser.nf.Formal(parser.pos(a), Flags.NONE, parser.array(a, 0),
	    UniqueID.newID("t")), b);

                                        :}
 |  TRAP:n LPAREN formal_parameter:a RPAREN block:b {:

      RESULT =
	parser.jmnf().Trap(parser.pos(n), a, b);

                                                    :};

default_trap_clause ::=
    TRAP:n class_type_list:a {:

      Block body = (Block)parser.jmnf().qq().parseStmt("{ throw new "
	+ "java.lang.IllegalStateException(); }");
      List l = new TypedList(new LinkedList(), Trap.class, false);
      for (Iterator it = a.iterator(); it.hasNext(); ) {
	TypeNode tn = (TypeNode)it.next();
	l.add(parser.jmnf().Trap(parser.pos(n),
	  parser.nf.Formal(parser.pos(tn), Flags.NONE, parser.array(tn, 0),
	    UniqueID.newID("t")), body));
      }
      RESULT = l;

                             :};

resume_statement ::=
    RESUME:n BREAK SEMICOLON {:

      RESULT = parser.jmnf().ResumeBreak(parser.pos(n));

                             :}
 |  RESUME:n BREAK trap_clauses:a {:

      RESULT = parser.jmnf().ResumeBreak(parser.pos(n), a);

                                  :}
 |  RESUME:n CONTINUE SEMICOLON {:

      RESULT = parser.jmnf().ResumeContinue(parser.pos(n));

                                :}
 |  RESUME:n CONTINUE trap_clauses:a {:

      RESULT = parser.jmnf().ResumeContinue(parser.pos(n), a);

                                     :}
 |  RESUME:n SEMICOLON {:

      RESULT = parser.jmnf().ResumeWith(parser.pos(n));

                       :}
 |  RESUME:n trap_clauses:a {:

      RESULT = parser.jmnf().ResumeWith(parser.pos(n), a);

                            :}
 |  RESUME:n WITH block:a trap_clauses_opt:b {:

      RESULT = parser.jmnf().ResumeWith(parser.pos(n), a, b);

                                             :}
 |  RESUME:n WITH LPAREN formula:a RPAREN trap_clauses_or_semi:b {:

      RESULT = parser.jmnf().ResumeWith(parser.pos(n), a, b);

                                                                 :};

trap_clauses_or_semi ::=
    SEMICOLON {:

      RESULT = new TypedList(new LinkedList(), Trap.class, false);

              :}
 |  trap_clauses:a {:
      RESULT = a;
     :};

trap_clauses_opt ::=
    {:

      RESULT = new TypedList(new LinkedList(), Trap.class, false);

    :}
 |  trap_clauses:a {:
      RESULT = a;
     :};

trap_clauses ::=
    trap_clause:a {:

      RESULT = new TypedList(new LinkedList(), Trap.class, false);
      RESULT.add(a);

                  :}
 |  default_trap_clause:a SEMICOLON {:
      RESULT = a;
     :}
 |  trap_clauses_no_semi:a trap_clause:b {:

      a.add(b);
      RESULT = a;

                                         :}
 |  trap_clauses_no_semi:a default_trap_clause:b SEMICOLON {:

      a.add(b);
      RESULT = a;

                                                           :};

trap_clauses_no_semi ::=
    trap_clause:a {:

      RESULT = new TypedList(new LinkedList(), Trap.class, false);
      RESULT.add(a);

                  :}
 |  default_trap_clause:a {:
      RESULT = a;
     :}
 |  trap_clauses_no_semi:a trap_clause:b {:

      a.add(b);
      RESULT = a;

                                         :}
 |  trap_clauses_no_semi:a default_trap_clause:b {:

      a.add(b);
      RESULT = a;

                                                 :};

foreach_statement ::=
    FOREACH:n LPAREN formula:a RPAREN statement:b {:

      RESULT = parser.jmnf().Foreach( parser.pos(n), a, b );

                                                  :};

foreach_statement_no_short_if ::=
    FOREACH:n LPAREN formula:a RPAREN statement_no_short_if:b {:

      RESULT = parser.jmnf().Foreach( parser.pos(n), a, b );

                                                              :};

let_statement ::=
    LET:n formula:a SEMICOLON {:

      RESULT = parser.jmnf().Let( parser.pos(n), a );

                              :};

cond_statement ::=
    COND:n LBRACE conditions:a RBRACE {:

      RESULT = parser.jmnf().Cond( parser.pos(n), a );

                                      :}
 |  COND:n LBRACE conditions:a ELSE statement:b RBRACE {:

      RESULT = parser.jmnf().Cond( parser.pos(n), a, b );

                                                       :};

conditions ::=
    LPAREN expression:a RPAREN block:b {:

      TypedList l = new TypedList( new LinkedList(), Condition.class, false );
      l.add( parser.jmnf().Condition( parser.pos(a), a, b ) );
      RESULT = l;

                                       :}
 |  conditions:a LPAREN expression:b RPAREN block:c {:

      a.add( parser.jmnf().Condition( parser.pos(b), b, c ) );
      RESULT = a;

                                                    :};

yield_statement ::=
    YIELD:n SEMICOLON {:

      RESULT = parser.jmnf().Yield( parser.pos(n) );

                      :};

expression_list ::=
    argument_list:a {:
      RESULT = a;
     :};

case_list ::=
    case:a {:

      List l = new TypedList( new LinkedList(), Receiver.class, false );
      l.add(a);
      RESULT = l;

           :}
 |  case_list:a COMMA case:b {:
      RESULT = a;
      a.add(b);
     :};

case ::=
    primitive_type:a {:
      RESULT = a;
     :}
 |  array_type:a {:

      RESULT = parser.replaceExts( (AmbTypeNode)a, new JMatchCaseCondExt() );

                 :}
 |  expression:a {:

      RESULT = a;

      if ( a instanceof AmbExpr || a instanceof Field ) {
	// Convert to a type and attach a JMatchCaseCondExt extension.
        if ( a instanceof AmbExpr ) {
	  RESULT = JMatchCaseCondExt.toType( (AmbExpr)a, parser.nf );
	} else {
	  RESULT = JMatchCaseCondExt.toType( (Field)a, parser.nf );
	}

	RESULT =
	  parser.replaceExts( (AmbTypeNode)RESULT, new JMatchCaseCondExt() );
      }

                 :};

formula ::=
    conditional_or_expression:a {:
      RESULT = a;
     :};

method_invocation ::=
    name:a LPAREN argument_list_opt:b RPAREN {:

      RESULT =
	parser.jmnf().AmbInvoc( parser.pos(a),
	  a.prefix == null ? null : a.prefix.toReceiver(),
	  a.name, a.toType(), b );

                                             :}
 |  primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN {:

      Name n = new Name( parser, parser.pos(b), b.getIdentifier() );

      RESULT =
	parser.jmnf().AmbInvoc( parser.pos(a), a, b.getIdentifier(), a,
	  n.toType(), c );

                                                                 :}
 |  SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN {:

      RESULT =
	parser.nf.Call( parser.pos(b), parser.nf.Super(parser.pos(a)),
	  b.getIdentifier(), c );

                                                               :}
 |  name:a DOT SUPER:n DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN {:

      RESULT = parser.nf.Call( parser.pos(b),
	parser.nf.Super( parser.pos(a), a.toType() ), b.getIdentifier(), c );

                                                                          :};

iterate_expression ::=
    ITERATE:i IDENTIFIER:a LPAREN formula:b RPAREN {:

	RESULT = parser.jmnf().Iterate( parser.pos(i), a.getIdentifier(), b );

                                                   :};

predicate_constructor_declaration ::=
    modifiers_opt:a IDENTIFIER:b LPAREN formal_parameter_list_opt:c RPAREN throws_opt:d predicate_constructor_implementations:e {:

      // Extract the PredMode for the first implementation.
      PredImpl impl = (PredImpl)e.get(0);
      PredMode m = impl.mode();

      Set unkSet = new HashSet();
      if ( m instanceof DefaultPredMode ) {
        m = parser.jmnf().PredMode( parser.pos(b), unkSet, parser.singular() );
	impl = impl.mode(m);
	e.set( 0, impl );
      } else {
        // Add a default mode if none was provided.
	boolean haveDefault = false;
	for ( Iterator it = e.iterator(); it.hasNext() && !haveDefault; ) {
	  PredImpl impl_ = (PredImpl)it.next();
	  m = impl_.mode();
	  haveDefault = unkSet.equals( m.unknowns() );
	}

	if ( !haveDefault ) {
	  m = parser.jmnf().PredMode( parser.pos(impl), unkSet,
	    parser.singular() );
	  impl = impl.mode(m);
	  e.add( 0, impl );
	}
      }

      RESULT =
	parser.jmnf().PredConstructorDecl( parser.pos(b), a, b.getIdentifier(),
	  c, d, e );

                                                                                                                                :};

predicate_constructor_implementations ::=
    default_predicate_implementation_opt:a predicate_implementations:b {:

      RESULT = a;
      a.addAll(b);

                                                                       :}
 |  default_predicate_implementation:a {:
      RESULT = a;
     :};

predicate_declaration ::=
    predicate_header:a predicate_body:b {:

      // Extract the PredMode for the first implementation.
      PredImpl impl = (PredImpl)b.get(0);
      PredMode m = impl.mode();

      Set unkSet = new HashSet();
      TypeNode returnType = a.returnType();
      if ( !parser.ts.Boolean().equals(returnType.type()) ) {
        unkSet.add( "result" );
      }

      if ( m instanceof DefaultPredMode ) {
        m = parser.jmnf().PredMode( parser.pos(a), unkSet, parser.singular() );
	impl = impl.mode(m);
	b.set( 0, impl );
      } else {
	// Add a default mode if none was provided.
	boolean haveDefault = false;
	for ( Iterator it = b.iterator(); it.hasNext() && !haveDefault; ) {
	  impl = (PredImpl)it.next();
	  m = impl.mode();
	  haveDefault = unkSet.equals(m.unknowns()) && m.mult().isSingular();
	}

	if ( !haveDefault ) {
	  // Find the first non-iterator implementation.  The default mode
	  // shares that same implementation.
	  impl = null;
	  ListIterator it;
	  for ( it = b.listIterator(); it.hasNext(); ) {
	    impl = (PredImpl)it.next();
	    if ( !(impl instanceof PredIterImpl) ) {
	      break;
	    }
	  }

	  m = parser.jmnf().PredMode( parser.pos(impl), unkSet,
	    parser.singular() );

	  if ( impl == null || impl instanceof PredIterImpl ) {
	    // Use an abstract implementation.
	    impl = parser.jmnf().PredAbstractImpl( parser.pos(a), m );
	  } else {
	    impl = impl.mode(m);
	  }

	  it.add(impl);
	}
      }

      RESULT = a.implementations(b);

                                        :};

abstract_predicate_declaration ::=
    predicate_header:a abstract_predicate_modes:b SEMICOLON {:

      RESULT = a.implementations(b);

                                                            :}
 |  predicate_header:a SEMICOLON {:

      Set unkSet = new HashSet();
      TypeNode returnType = a.returnType();
      if ( !parser.ts.Boolean().equals( returnType.type() ) ) {
        unkSet.add( "result" );
      }

      PredMode m = parser.jmnf().PredMode( parser.pos(a), unkSet,
	parser.singular() );
      PredImpl impl = parser.jmnf().PredAbstractImpl( parser.pos(a), m );

      TypedList l = new TypedList( new ArrayList(1), PredImpl.class, false );
      l.add(impl);

      RESULT = a.implementations(l);

                                 :};

predicate_header ::=
    modifiers_opt:a type:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN dims_opt:e throws_opt:f traps_opt:g {:

      RESULT = parser.jmnf().PredDecl( parser.pos(c), a,
	parser.array(b, e.intValue()), c.getIdentifier(), d, f, g,
	new ArrayList() );

                                                                                                                      :}
 |  modifiers_opt:a VOID:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN throws_opt:f traps_opt:g {:

      RESULT = parser.jmnf().PredDecl( parser.pos(c), a,
	parser.nf.CanonicalTypeNode( parser.pos(b), parser.ts.Void() ),
	c.getIdentifier(), d, f, g, new ArrayList() );

                                                                                                           :};

traps_opt ::=
    {:

      RESULT = new TypedList(new LinkedList(), TypeNode.class, false);

    :}
 |  TRAPS class_type_list:a {:
      RESULT = a;
     :};

predicate_body ::=
    default_predicate_implementation_opt:a predicate_body_:b {:

      RESULT = a;
      a.addAll(b);

                                                             :}
 |  default_predicate_implementation:a {:
      RESULT = a;
     :}
 |  SEMICOLON:a {:

      PredMode m = parser.jmnf().DefaultPredMode(parser.pos(a));
      PredImpl impl = parser.jmnf().PredAbstractImpl( parser.pos(a), m );
      RESULT = new TypedList( new ArrayList(1), PredImpl.class, false );
      RESULT.add( impl );

                :};

default_predicate_implementation_opt ::=
    {:

      RESULT = new TypedList( new LinkedList(), PredImpl.class, false );

    :}
 |  default_predicate_implementation:a {:
      RESULT = a;
     :};

default_predicate_implementation ::=
    predicate_iter_impl_body:a {:

      TypedList l = new TypedList( new LinkedList(), PredImpl.class, false );
      PredMode m = parser.jmnf().DefaultPredMode( parser.pos(a) );
      l.add( parser.jmnf().PredIterImpl( parser.pos(a), m, a ) );
      RESULT = l;

                               :}
 |  predicate_fmla_impl_body:a {:

      TypedList l = new TypedList( new LinkedList(), PredImpl.class, false );
      PredMode m = parser.jmnf().DefaultPredMode( parser.pos(a) );
      l.add( parser.jmnf().PredFmlaImpl( parser.pos(a), m, a ) );
      RESULT = l;

                               :};

predicate_body_ ::=
    predicate_implementations:a abstract_predicate_modes:b SEMICOLON {:

      a.addAll(b);
      RESULT = a;

                                                                     :}
 |  predicate_implementations:a {:
      RESULT = a;
     :}
 |  abstract_predicate_modes:a SEMICOLON {:
      RESULT = a;
     :};

predicate_implementations ::=
    predicate_modes:a predicate_fmla_impl_body:b {:

      TypedList l = new TypedList( new LinkedList(), PredImpl.class, false );
      for ( Iterator it = a.iterator(); it.hasNext(); ) {
        PredMode m = (PredMode)it.next();
	l.add( parser.jmnf().PredFmlaImpl( parser.pos(m), m, b ) );
      }

      RESULT = l;

                                                 :}
 |  predicate_modes:a predicate_iter_impl_body:b {:

      PredMode m = (PredMode)a.get(0);

      // Force there to be only one predicate mode.
      if ( a.size() != 1 ) {
	parser.die( parser.pos(m) );
      }

      TypedList l = new TypedList( new LinkedList(), PredImpl.class, false );
      l.add( parser.jmnf().PredIterImpl( parser.pos(m), m, b ) );

      RESULT = l;

                                                 :}
 |  predicate_implementations:a predicate_modes:b predicate_fmla_impl_body:c {:

      for ( Iterator it = b.iterator(); it.hasNext(); ) {
        PredMode m = (PredMode)it.next();
	a.add( parser.jmnf().PredFmlaImpl( parser.pos(m), m, c ) );
      }

      RESULT = a;

                                                                             :}
 |  predicate_implementations:a predicate_modes:b predicate_iter_impl_body:c {:

      PredMode m = (PredMode)b.get(0);

      // Force there to be only one predicate mode.
      if ( b.size() != 1 ) {
	parser.die( parser.pos(m) );
      }

      a.add( parser.jmnf().PredIterImpl( parser.pos(m), m, c ) );

      RESULT = a;

                                                                             :};

abstract_predicate_modes ::=
    predicate_modes:a {:

      TypedList l = new TypedList( new LinkedList(), PredImpl.class, false );
      for ( Iterator it = a.iterator(); it.hasNext(); ) {
        PredMode m = (PredMode)it.next();
	l.add( parser.jmnf().PredAbstractImpl( parser.pos(m), m ) );
      }

      RESULT = l;

                      :};

predicate_modes ::=
    predicate_mode_list:a {:
      RESULT = a;
     :}
 |  predicate_modes:a predicate_mode_list:b {:

      a.addAll(b);
      RESULT = a;

                                            :};

predicate_mode_list ::=
    ITERATES:a LPAREN unknown_lists:b RPAREN:c {:

      List l = new TypedList( new ArrayList(b.size()), PredMode.class, false );
      for ( Iterator it = b.iterator(); it.hasNext(); ) {
	Object[] entry = (Object[])it.next();
	Set mode = (Set)entry[0];
	Position pos = (Position)entry[1];

	if ( pos == null ) {
	  pos = parser.pos(c);
	}

	l.add( parser.jmnf().PredMode( pos, mode, parser.multiple() ) );
      }

      RESULT = l;

                                               :}
 |  RETURNS:a LPAREN unknown_lists:b RPAREN:c {:

      List l = new TypedList( new ArrayList(b.size()), PredMode.class, false );
      for ( Iterator it = b.iterator(); it.hasNext(); ) {
	Object[] entry = (Object[])it.next();
	Set mode = (Set)entry[0];
	Position pos = (Position)entry[1];

	if ( pos == null ) {
	  pos = parser.pos(c);
	}

	l.add( parser.jmnf().PredMode( pos, mode, parser.singular() ) );
      }

      RESULT = l;

                                              :};

unknown_lists ::=
    unknown_list:a {:

      TypedList l = new TypedList( new LinkedList(), Object[].class, false );
      l.add(a);
      RESULT = l;

                   :}
 |  unknown_lists:a SEMICOLON:n unknown_list:b {:

      // If the last unknown list we got was empty, then set its position to
      // that of the semicolon.
      Object[] lastMode = (Object[])a.get(a.size()-1);
      if ( lastMode[1] == null ) {
        lastMode[1] = parser.pos(n);
	a.set( a.size()-1, lastMode );
      }

      a.add(b);
      RESULT = a;

                                               :};

unknown_list ::=
    {:

      RESULT = new Object[2];
      RESULT[0] = new HashSet();
      RESULT[1] = null;

    :}
 |  non_empty_unknown_list:a {:
      RESULT = a;
     :};

non_empty_unknown_list ::=
    IDENTIFIER:a {:

      Set s = new HashSet();
      s.add( a.getIdentifier() );

      RESULT = new Object[2];
      RESULT[0] = s;
      RESULT[1] = parser.pos(a);

                 :}
 |  non_empty_unknown_list:a COMMA IDENTIFIER:b {:

      ((Set)a[0]).add( b.getIdentifier() );
      RESULT = a;

                                                :};

predicate_fmla_impl_body ::=
    LPAREN formula:a RPAREN {:
      RESULT = a;
     :};

predicate_iter_impl_body ::=
    block:a {:
      RESULT = a;
     :};


