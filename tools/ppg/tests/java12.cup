package polyglot.ext.jl.parse;

import java.util.*;

import java_cup.runtime.*;

import polyglot.ast.*;
import polyglot.lex.*;
import polyglot.parse.*;
import polyglot.types.*;
import polyglot.util.*;

// This parser is based on:
/* Java 1.2 parser for CUP.
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 *
 * As a special exception, C. Scott Ananian additionally permits the use of
 * this modified version of the parser, distributed with Polyglot, under
 * the terms of the LGPL.
 */

parser code {:
    ErrorQueue eq;
	Lexer lexer;
    TypeSystem ts;
    NodeFactory nf;
    JLUtil util;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        this();
        eq = q;
		lexer = l;
        ts = t;
        nf = n;
        util = new JLUtil(new JLParserWrapper(this));
    }

    /**
	 * Override the default CUP routine.
	 */
    public void syntax_error(java_cup.runtime.Symbol current) {
        Position p = ((Token) current.value).getPosition();

        if (current.sym == sym.EOF) {
            report_error("Unexpected end of file.", p);
        } else {
            report_error("Syntax error.", p);
        }
    }

	/**
	 * Override the default CUP routine.
	 */
    public void report_error(String message, Object info) {
        if (info instanceof Position) {
            eq.enqueue(ErrorInfo.SYNTAX_ERROR, message, (Position) info);
        } else {
            eq.enqueue(ErrorInfo.SYNTAX_ERROR, message);
        }
    }

	/**
	 * Override the default CUP routine.
	 */
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		eq.enqueue(ErrorInfo.SYNTAX_ERROR, "Unable to recover from previous errors.");
	}

	/**
	 * Report a fatal error then abort parsing.
	 */
    public void die(String msg, Position pos) throws Exception {
		report_fatal_error(msg, pos);
        die();
    }

	/**
	 * Report a fatal error then abort parsing.
	 */
    public void die(Position pos) throws Exception {
		report_fatal_error("Syntax error.", pos);
        die();
    }

   	/**
	 * Report a fatal error then abort parsing.
	 */
    public void die() throws Exception {
		throw new Exception("Couldn't repair and continue parse");
    }

:};

scan with {:
  return lexer.nextToken().symbol();
:};

terminal Token BOOLEAN; // primitive_type
terminal Token BYTE, SHORT, INT, LONG, CHAR; // integral_type
terminal Token FLOAT, DOUBLE; // floating_point_type
terminal Token LBRACK, RBRACK; // array_type
terminal Identifier IDENTIFIER; // name
terminal Token DOT; // qualified_name
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ; // separators
terminal Token LPAREN, RPAREN, COLON; // more separators
terminal Token PACKAGE; // package_declaration
terminal Token IMPORT; // import_declaration
terminal Token PUBLIC, PROTECTED, PRIVATE; // modifier
terminal Token STATIC; // modifier
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS; // class_declaration
terminal Token EXTENDS; // super
terminal Token IMPLEMENTS; // interfaces
terminal Token VOID; // method_header
terminal Token THROWS; // throws
terminal Token THIS, SUPER; // explicit_constructor_invocation
terminal Token INTERFACE; // interface_declaration
terminal Token IF, ELSE; // if_then_statement, if_then_else_statement
terminal Token SWITCH; // switch_statement
terminal Token CASE, DEFAULT; // switch_label
terminal Token DO, WHILE; // while_statement, do_statement
terminal Token FOR; // for_statement
terminal Token BREAK; // break_statement
terminal Token CONTINUE; // continue_statement
terminal Token RETURN; // return_statement
terminal Token THROW; // throw_statement
terminal Token TRY; // try_statement
terminal Token CATCH; // catch_clause
terminal Token FINALLY; // finally
terminal Token NEW; // class_instance_creation_expression
terminal Token PLUSPLUS; // postincrement_expression
terminal Token MINUSMINUS; // postdecrement_expression
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal Token EQEQ, NOTEQ; // equality_expression
terminal Token AND; // and_expression
terminal Token XOR; // exclusive_or_expression
terminal Token OR;  // inclusive_or_expression
terminal Token ANDAND; // conditional_and_expression
terminal Token OROR; // conditional_or_expression
terminal Token QUESTION; // conditional_expression
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal Token ANDEQ, XOREQ, OREQ; // assignment_operator

terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL;
terminal polyglot.lex.LongLiteral LONG_LITERAL;
terminal polyglot.lex.DoubleLiteral DOUBLE_LITERAL;
terminal polyglot.lex.FloatLiteral FLOAT_LITERAL;
terminal polyglot.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal polyglot.lex.CharacterLiteral CHARACTER_LITERAL;
terminal polyglot.lex.StringLiteral STRING_LITERAL;
terminal polyglot.lex.NullLiteral NULL_LITERAL;

// strictfp keyword, new in Java 1.2
terminal Token STRICTFP;

// Reserved but unused:
terminal CONST, GOTO;

// 19.2) The Syntactic Grammar
non terminal SourceFile goal;
// 19.3) Lexical Structure
non terminal polyglot.ast.Lit literal;
// 19.4) Types, Values, and Variables
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode class_type, interface_type;
non terminal TypeNode array_type;
// 19.5) Names
non terminal Name name, simple_name, qualified_name;
// 19.6) Packages
non terminal SourceFile compilation_unit;
non terminal PackageNode package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal Import import_declaration;
non terminal Import single_type_import_declaration;
non terminal Import type_import_on_demand_declaration;
non terminal ClassDecl type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal Flags modifiers_opt, modifiers, modifier;
// 19.8.1) Class Declaration
non terminal ClassDecl class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal ClassBody class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal List class_body_declaration, class_member_declaration;
// 19.8.2) Field Declarations
non terminal List field_declaration;
non terminal List variable_declarators;
non terminal VarDeclarator variable_declarator;
non terminal VarDeclarator variable_declarator_id;
non terminal Expr variable_initializer;
// 19.8.3) Method Declarations
non terminal MethodDecl method_declaration, method_header;
non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal Formal formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;
non terminal Block method_body;
// 19.8.4) Static Initializers
non terminal Block static_initializer;
// 19.8.5) Constructor Declarations
non terminal ConstructorDecl constructor_declaration;
non terminal Block constructor_body;
non terminal ConstructorCall explicit_constructor_invocation;
// 19.9.1) Interface Declarations
non terminal ClassDecl interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal ClassBody interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal List interface_member_declaration;
non terminal List constant_declaration;
non terminal MethodDecl abstract_method_declaration;
// 19.10) Arrays
non terminal ArrayInit array_initializer;
non terminal List variable_initializers;
// 19.11) Blocks and Statements
non terminal Block block;
non terminal List block_statements_opt, block_statements;
non terminal List block_statement;
non terminal List local_variable_declaration_statement;
non terminal List local_variable_declaration;
non terminal Stmt statement, statement_no_short_if;
non terminal Stmt statement_without_trailing_substatement;
non terminal Empty empty_statement;
non terminal Labeled labeled_statement, labeled_statement_no_short_if;
non terminal Stmt expression_statement;
non terminal Expr statement_expression;
non terminal If if_then_statement;
non terminal If if_then_else_statement, if_then_else_statement_no_short_if;
non terminal Switch switch_statement;
non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;
non terminal Case switch_label;
non terminal While while_statement, while_statement_no_short_if;
non terminal Do do_statement;
non terminal For for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal Name identifier_opt;
non terminal Branch break_statement, continue_statement;
non terminal Return return_statement;
non terminal Throw throw_statement;
non terminal Synchronized synchronized_statement;
non terminal Try try_statement;
non terminal List catches_opt, catches;
non terminal Catch catch_clause;
non terminal Block finally;
// 19.12) Expressions
non terminal Expr primary, primary_no_new_array;
non terminal Expr class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal NewArray array_creation_expression;
non terminal List dim_exprs;
non terminal Expr dim_expr;
non terminal Integer dims_opt, dims;
non terminal Field field_access;
non terminal Call method_invocation;
non terminal ArrayAccess array_access;
non terminal Expr postfix_expression;
non terminal Unary postincrement_expression, postdecrement_expression;
non terminal Expr unary_expression, unary_expression_not_plus_minus;
non terminal Unary preincrement_expression, predecrement_expression;
non terminal Cast cast_expression;
non terminal Expr multiplicative_expression, additive_expression;
non terminal Expr shift_expression, relational_expression, equality_expression;
non terminal Expr and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expr conditional_and_expression, conditional_or_expression;
non terminal Expr conditional_expression, assignment_expression;
non terminal Expr assignment;
non terminal Expr left_hand_side;
non terminal Assign.Operator assignment_operator;
non terminal Expr expression_opt, expression;
non terminal Expr constant_expression;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=
                    // SourceFile
        compilation_unit:a
            {: RESULT = a; :}
    ;

// 19.3) Lexical Structure.
literal ::=
                    // Lit
        INTEGER_LITERAL:a
            {: RESULT = parser.nf.IntLit(parser.util.pos(a),
	                                 a.getValue().intValue()); :}
    |   LONG_LITERAL:a
            {: RESULT = parser.nf.IntLit(parser.util.pos(a),
					 a.getValue().longValue()); :}
    |   DOUBLE_LITERAL:a
            {: RESULT = parser.nf.FloatLit(parser.util.pos(a), FloatLit.DOUBLE,
                                           a.getValue().doubleValue()); :}
    |   FLOAT_LITERAL:a
            {: RESULT = parser.nf.FloatLit(parser.util.pos(a), FloatLit.FLOAT,
                                           a.getValue().floatValue()); :}
    |   BOOLEAN_LITERAL:a
            {: RESULT = parser.nf.BooleanLit(parser.util.pos(a),
	                                     a.getValue().booleanValue()); :}
    |   CHARACTER_LITERAL:a
            {: RESULT = parser.nf.CharLit(parser.util.pos(a),
					  a.getValue().charValue()); :}
    |   STRING_LITERAL:a
            {: RESULT = parser.nf.StringLit(parser.util.pos(a), a.getValue()); :}
    |   NULL_LITERAL:a
            {: RESULT = parser.nf.NullLit(parser.util.pos(a)); :}
    ;

// 19.4) Types, Values, and Variables
type    ::=
                    // TypeNode
        primitive_type:a
            {: RESULT = a; :}
    |   reference_type:a
            {: RESULT = a; :}
    ;
primitive_type ::=
                    // TypeNode
        numeric_type:a
            {: RESULT = a; :}
    |   BOOLEAN:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a), parser.ts.Boolean()); :}
    ;
numeric_type::=
                    // TypeNode
        integral_type:a
            {: RESULT = a; :}
    |   floating_point_type:a
            {: RESULT = a; :}
    ;
integral_type ::=
                    // TypeNode
        BYTE:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a), parser.ts.Byte()); :}
    |   CHAR:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a), parser.ts.Char()); :}
	|   SHORT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a), parser.ts.Short()); :}
    |   INT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a), parser.ts.Int()); :}
    |   LONG:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a), parser.ts.Long()); :}
    ;
floating_point_type ::=
                    // TypeNode
        FLOAT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a),
					   parser.ts.Float()); :}
    |   DOUBLE:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.util.pos(a),
					   parser.ts.Double()); :}
    ;
reference_type ::=
                    // TypeNode
        class_or_interface_type:a
            {: RESULT = a; :}
    |   array_type:a
            {: RESULT = a; :}
    ;
class_or_interface_type ::=
                    // TypeNode
        name:a
            {: RESULT = a.toType(); :}
    ;
class_type ::=
                    // TypeNode
        class_or_interface_type:a
            {: RESULT = a; :}
    ;
interface_type ::=
                    // TypeNode
        class_or_interface_type:a
            {: RESULT = a; :}
    ;
array_type ::=
                    // TypeNode
        primitive_type:a dims:b
            {: RESULT = parser.util.array(a, b.intValue()); :}
    |   name:a dims:b
            {: RESULT = parser.util.array(a.toType(), b.intValue()); :}
    ;
// 19.5) Names
name    ::=
                    // Name
        simple_name:a
            {: RESULT = a; :}
    |   qualified_name:a
            {: RESULT = a; :}
    ;
simple_name ::=
                    // Name
        IDENTIFIER:a
            {: RESULT = new Name(parser, parser.util.pos(a), a.getIdentifier()); :}
    ;
qualified_name ::=
                    // Name
        name:a DOT IDENTIFIER:b
            {: RESULT = new Name(parser, parser.util.pos(a), a, b.getIdentifier()); :}
    ;
// 19.6) Packages
compilation_unit ::=
                    // SourceFile
        package_declaration_opt:a
        import_declarations_opt:b
        type_declarations_opt:c
            {: RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()), a, b, c); :}
        ;
package_declaration_opt ::=
                    // PackageNode
        package_declaration:a
            {: RESULT = a; :}
    |
            {: RESULT = null; :}
    ;
import_declarations_opt ::=
                    // List of Import
        import_declarations:a
            {: RESULT = a; :}
    |
            {: RESULT = new TypedList(new LinkedList(), Import.class, false); :}
    ;
type_declarations_opt   ::=
                    // List of ClassDecl
        type_declarations:a
            {: RESULT = a; :}
    |
            {: RESULT = new TypedList(new LinkedList(), ClassDecl.class, false); :}
    ;
import_declarations ::=
                    // List of Import
        import_declaration:a
            {: List l = new TypedList(new LinkedList(), Import.class, false);
			   l.add(a);
			   RESULT = l; :}
    |   import_declarations:a import_declaration:b
            {: RESULT = a;
			   a.add(b); :}
    ;
type_declarations ::=
                    // List of ClassDecl
        type_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassDecl.class, false);
               if (a != null)
                   l.add(a);
               RESULT = l; :}
    |   type_declarations:a type_declaration:b
            {: RESULT = a;
               if (b != null)
                   a.add(b); :}
    ;
package_declaration ::=
                    // PackageNode
        PACKAGE name:a SEMICOLON
            {: RESULT = a.toPackage(); :}
    ;
import_declaration ::=
                    // Import
        single_type_import_declaration:a
            {: RESULT = a; :}
    |   type_import_on_demand_declaration:a
            {: RESULT = a; :}
    ;
single_type_import_declaration ::=
                    // Import
        IMPORT name:a SEMICOLON
            {: RESULT = parser.nf.Import(parser.util.pos(a), Import.CLASS, a.toString()); :}
    ;
type_import_on_demand_declaration ::=
                    // Import
        IMPORT name:a DOT MULT SEMICOLON
            {: RESULT = parser.nf.Import(parser.util.pos(a), Import.PACKAGE, a.toString()); :}
    ;
type_declaration ::=
                    // ClassDecl
        class_declaration:a
            {: RESULT = a; :}
    |   interface_declaration:a
            {: RESULT = a; :}
    |   SEMICOLON
            {: RESULT = null; :}
    ;

// 19.7) Productions used only in the LALR(1) grammar
modifiers_opt::=
                    // Flags
            {: RESULT = Flags.NONE; :}
    |   modifiers:a
            {: RESULT = a; :}
    ;
modifiers ::=
                    // Flags
        modifier:a
            {: RESULT = a; :}
    |   modifiers:a modifier:b
            {: RESULT = a.set(b); :}
    ;
modifier ::=
                    // Flags
        PUBLIC:a
            {: RESULT = Flags.PUBLIC; :}
    |   PROTECTED:a
            {: RESULT = Flags.PROTECTED; :}
    |   PRIVATE:a
            {: RESULT = Flags.PRIVATE; :}
    |   STATIC:a
            {: RESULT = Flags.STATIC; :}
    |   ABSTRACT:a
            {: RESULT = Flags.ABSTRACT; :}
    |   FINAL:a
            {: RESULT = Flags.FINAL; :}
    |   NATIVE:a
            {: RESULT = Flags.NATIVE; :}
    |   SYNCHRONIZED:a
            {: RESULT = Flags.SYNCHRONIZED; :}
    |   TRANSIENT:a
            {: RESULT = Flags.TRANSIENT; :}
    |   VOLATILE:a
            {: RESULT = Flags.VOLATILE; :}
    |   STRICTFP:a
            {: RESULT = Flags.STRICTFP; :}
    ;
// 19.8) Classes

// 19.8.1) Class Declarations
class_declaration ::=
                    // ClassDecl
        modifiers_opt:a CLASS:n IDENTIFIER:b
				super_opt:c interfaces_opt:d class_body:e
            {: RESULT = parser.nf.ClassDecl(parser.util.pos(n),
				a, b.getIdentifier(), c, d, e); :}
    ;
super ::=
                    // TypeNode
        EXTENDS class_type:a
            {: RESULT = a; :}
    ;
super_opt ::=
                    // TypeNode
    |   super:a
            {: RESULT = a; :}
    ;
interfaces ::=
                    // List of TypeNode
        IMPLEMENTS interface_type_list:a
            {: RESULT = a; :}
    ;
interfaces_opt::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   interfaces:a
            {: RESULT = a; :}
    ;
interface_type_list ::=
                    // List of TypeNode
        interface_type:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   interface_type_list:a COMMA interface_type:b
            {: RESULT = a;
               a.add(b); :}
    ;
class_body ::=
                    // ClassBody
        LBRACE:n class_body_declarations_opt:a RBRACE
            {: RESULT = parser.nf.ClassBody(parser.util.pos(n), a); :}
    ;
class_body_declarations_opt ::=
                    // List of ClassMember
            {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |   class_body_declarations:a
            {: RESULT = a; :}
    ;
class_body_declarations ::=
                    // List of ClassMember
        class_body_declaration:a
            {: RESULT = a; :}
    |   class_body_declarations:a class_body_declaration:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
class_body_declaration ::=
                    // List of ClassMember
        class_member_declaration:a
            {: RESULT = a; :}
    |   static_initializer:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.util.pos(a), Flags.STATIC, a));
               RESULT = l; :}
    |   constructor_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   block:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.util.pos(a), Flags.NONE, a));
               RESULT = l; :}
    ;
class_member_declaration ::=
                    // List of ClassMember
        field_declaration:a
            {: RESULT = a; :}
    |   method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
        /* repeat the prod for 'class_declaration' here: */
	|   modifiers_opt:a CLASS:n IDENTIFIER:b
					super_opt:c interfaces_opt:d class_body:e
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.ClassDecl(parser.util.pos(n),
			            a, b.getIdentifier(), c, d, e));
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    ;

// 19.8.2) Field Declarations
field_declaration ::=
                    // List of ClassMember
        modifiers_opt:a type:b variable_declarators:c SEMICOLON
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               for (Iterator i = c.iterator(); i.hasNext(); ) {
                   VarDeclarator d = (VarDeclarator) i.next();
                   l.add(parser.nf.FieldDecl(parser.util.pos(b),
                                             a, parser.util.array(b, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    ;
variable_declarators ::=
                    // List of VarDeclarator
        variable_declarator:a
            {: List l = new TypedList(new LinkedList(), VarDeclarator.class, false);
               l.add(a);
               RESULT = l; :}
    |   variable_declarators:a COMMA variable_declarator:b
            {: RESULT = a;
               a.add(b); :}
    ;
variable_declarator ::=
                // VarDeclarator
        variable_declarator_id:a
            {: RESULT = a; :}
    |   variable_declarator_id:a EQ variable_initializer:b
            {: RESULT = a;
               a.init = b; :}
    ;
variable_declarator_id ::=
                // VarDeclarator
        IDENTIFIER:a
            {: RESULT = new VarDeclarator(parser.util.pos(a),
							a.getIdentifier()); :}
    |   variable_declarator_id:a LBRACK RBRACK
            {: RESULT = a;
               a.dims++; :}
    ;
variable_initializer ::=
                    // Expr
        expression:a
            {: RESULT = a; :}
    |   array_initializer:a
            {: RESULT = a; :}
    ;

// 19.8.3) Method Declarations
method_declaration ::=
                    // MethodDecl
        method_header:a method_body:b
            {: RESULT = a.body(b); :}
    ;
method_header ::=
                    // MethodDecl
        modifiers_opt:a type:b IDENTIFIER:c LPAREN
				formal_parameter_list_opt:d RPAREN dims_opt:e throws_opt:f
            {: RESULT = parser.nf.MethodDecl(parser.util.pos(c), a,
	    		parser.util.array(b, e.intValue()), c.getIdentifier(),
				d, f, null); :}
    |   modifiers_opt:a VOID:b IDENTIFIER:c LPAREN
				formal_parameter_list_opt:d RPAREN throws_opt:f
            {: RESULT = parser.nf.MethodDecl(parser.util.pos(c), a,
				parser.nf.CanonicalTypeNode(parser.util.pos(b),
				parser.ts.Void()), c.getIdentifier(), d, f, null); :}
    ;
formal_parameter_list_opt ::=
                    // List of Formal
            {: RESULT = new TypedList(new LinkedList(), Formal.class, false); :}
    |   formal_parameter_list:a
            {: RESULT = a; :}
    ;
formal_parameter_list ::=
                    // List of Formal
        formal_parameter:a
            {: List l = new TypedList(new LinkedList(), Formal.class, false);
               l.add(a);
               RESULT = l; :}
    |   formal_parameter_list:a COMMA formal_parameter:b
            {: RESULT = a;
               a.add(b); :}
    ;
formal_parameter ::=
                    // Formal
        type:a variable_declarator_id:b
            {: RESULT = parser.nf.Formal(parser.util.pos(b), Flags.NONE,
                                         parser.util.array(a, b.dims), b.name); :}
    |   FINAL type:a variable_declarator_id:b
            {: RESULT = parser.nf.Formal(parser.util.pos(b), Flags.FINAL,
					 parser.util.array(a, b.dims), b.name); :}
    ;
throws_opt ::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   throws:a
            {: RESULT = a; :}
    ;
throws ::=
                    // List of TypeNode
        THROWS class_type_list:a
            {: RESULT = a; :}
    ;
class_type_list ::=
                    // List of TypeNode
        class_type:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_type_list:a COMMA class_type:b
            {: RESULT = a;
               a.add(b); :}
    ;
method_body ::=
                    // Block
        block:a
            {: RESULT = a; :}
    |   SEMICOLON
            {: RESULT = null; :}
    ;

// 19.8.4) Static Initializers
static_initializer ::=
                    // Block
        STATIC block:a
            {: RESULT = a; :}
    ;

// 19.8.5) Constructor Declarations
constructor_declaration ::=
					// ConstructorDecl
		modifiers_opt:m simple_name:a LPAREN formal_parameter_list_opt:b RPAREN
			throws_opt:c constructor_body:d
			{: RESULT = parser.nf.ConstructorDecl(parser.util.pos(a), m, a.toString(), b,
				c, d); :}
	;
constructor_body ::=
                    // Block
        LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               l.addAll(b);
               RESULT = parser.nf.Block(parser.util.pos(n), l); :}
    |   LBRACE:n explicit_constructor_invocation:a RBRACE
            {: RESULT = parser.nf.Block(parser.util.pos(n), a); :}
    |   LBRACE:n block_statements:a RBRACE
            {: RESULT = parser.nf.Block(parser.util.pos(n), a); :}
    |   LBRACE:n RBRACE
            {: RESULT = parser.nf.Block(parser.util.pos(n)); :}
    ;
explicit_constructor_invocation ::=
                    // ConstructorCall
        THIS:a LPAREN argument_list_opt:b RPAREN SEMICOLON
            {: RESULT = parser.nf.ThisCall(parser.util.pos(a), b); :}
    |   SUPER:a LPAREN argument_list_opt:b RPAREN SEMICOLON
            {: RESULT = parser.nf.SuperCall(parser.util.pos(a), b); :}
    |   primary:a DOT THIS:n LPAREN argument_list_opt:b RPAREN SEMICOLON
            {: RESULT = parser.nf.ThisCall(parser.util.pos(n), a, b); :}
    |   primary:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON
            {: RESULT = parser.nf.SuperCall(parser.util.pos(n), a, b); :}
    ;

// 19.9) Interfaces

// 19.9.1) Interface Declarations
interface_declaration ::=
                    // ClassDecl
        modifiers_opt:a INTERFACE:n IDENTIFIER:b
                extends_interfaces_opt:c interface_body:d
            {: RESULT = parser.nf.ClassDecl(
					parser.util.pos(n), a.setInterface(),
					    b.getIdentifier(), null, c, d); :}
    ;
extends_interfaces_opt ::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   extends_interfaces:a
            {: RESULT = a; :}
    ;
extends_interfaces ::=
                    // List of TypeNode
        EXTENDS interface_type:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   extends_interfaces:a COMMA interface_type:b
            {: RESULT = a;
               a.add(b); :}
    ;
interface_body ::=
                    // ClassBody
        LBRACE:n interface_member_declarations_opt:a RBRACE
            {: RESULT = parser.nf.ClassBody(parser.util.pos(n), a); :}
    ;
interface_member_declarations_opt ::=
                    // List of ClassMember
            {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |   interface_member_declarations:a
            {: RESULT = a; :}
    ;
interface_member_declarations ::=
                    // List of ClassMember
        interface_member_declaration:a
            {: RESULT = a; :}
    |   interface_member_declarations:a interface_member_declaration:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
interface_member_declaration ::=
                    // List of ClassMember
        constant_declaration:a
            {: RESULT = a; :}
    |   abstract_method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    ;
constant_declaration ::=
                    // List of ClassMember
        field_declaration:a
            {: RESULT = a; :}
    ;
abstract_method_declaration ::=
                    // MethodDecl
        method_header:a SEMICOLON
            {: RESULT = a; :}
    ;

// 19.10) Arrays
array_initializer ::=
                    // ArrayInit
        LBRACE:n variable_initializers:a COMMA RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.util.pos(n), a); :}
    |   LBRACE:n variable_initializers:a RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.util.pos(n), a); :}
    |   LBRACE:n COMMA RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.util.pos(n)); :}
    |   LBRACE:n RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.util.pos(n)); :}
    ;
variable_initializers ::=
                    // List of Expr
        variable_initializer:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
	       l.add(a);
	       RESULT = l; :}
    |   variable_initializers:a COMMA variable_initializer:b
            {: RESULT = a; a.add(b); :}
    ;

// 19.11) Blocks and Statements
block ::=
                    // Block
        LBRACE:n block_statements_opt:a RBRACE
            {: RESULT = parser.nf.Block(parser.util.pos(n), a); :}
    ;
block_statements_opt ::=
                    // List of Stmt
            {: RESULT = new TypedList(new LinkedList(), Stmt.class, false); :}
    |   block_statements:a
            {: RESULT = a; :}
    ;
block_statements ::=
                    // List of Stmt
        block_statement:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               RESULT = l; :}
    |   block_statements:a block_statement:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
block_statement ::=
                    // List of Stmt
        local_variable_declaration_statement:a
            {: RESULT = a; :}
    |   statement:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_declaration:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.util.pos(a), a));
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.util.pos(a), a));
               RESULT = l; :}
    ;
local_variable_declaration_statement ::=
                    // List of LocalDecl
        local_variable_declaration:a SEMICOLON
            {: RESULT = a; :}
    ;
local_variable_declaration ::=
                    // List of LocalDecl
        type:a variable_declarators:b
            {: List l = new TypedList(new LinkedList(), LocalDecl.class, false);
               for (Iterator i = b.iterator(); i.hasNext(); ) {
                   VarDeclarator d = (VarDeclarator) i.next();
                   l.add(parser.nf.LocalDecl(parser.util.pos(a), Flags.NONE,
                                             parser.util.array(a, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    |   FINAL type:a variable_declarators:b
            {: List l = new TypedList(new LinkedList(), LocalDecl.class, false);
               for (Iterator i = b.iterator(); i.hasNext(); ) {
                   VarDeclarator d = (VarDeclarator) i.next();
                   l.add(parser.nf.LocalDecl(parser.util.pos(a), Flags.FINAL,
                                             parser.util.array(a, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    ;
statement ::=
                    // Stmt
        statement_without_trailing_substatement:a
            {: RESULT = a; :}
    |   labeled_statement:a
            {: RESULT = a; :}
    |   if_then_statement:a
            {: RESULT = a; :}
    |   if_then_else_statement:a
            {: RESULT = a; :}
    |   while_statement:a
            {: RESULT = a; :}
    |   for_statement:a
            {: RESULT = a; :}
    ;
statement_no_short_if ::=
                    // Stmt
        statement_without_trailing_substatement:a
            {: RESULT = a; :}
    |   labeled_statement_no_short_if:a
            {: RESULT = a; :}
    |   if_then_else_statement_no_short_if:a
            {: RESULT = a; :}
    |   while_statement_no_short_if:a
            {: RESULT = a; :}
    |   for_statement_no_short_if:a
            {: RESULT = a; :}
    ;
statement_without_trailing_substatement ::=
                    // Stmt
        block:a
            {: RESULT = a; :}
    |   empty_statement:a
            {: RESULT = a; :}
    |   expression_statement:a
            {: RESULT = a; :}
    |   switch_statement:a
            {: RESULT = a; :}
    |   do_statement:a
            {: RESULT = a; :}
    |   break_statement:a
            {: RESULT = a; :}
    |   continue_statement:a
            {: RESULT = a; :}
    |   return_statement:a
            {: RESULT = a; :}
    |   synchronized_statement:a
            {: RESULT = a; :}
    |   throw_statement:a
            {: RESULT = a; :}
    |   try_statement:a
            {: RESULT = a; :}
    ;
empty_statement ::=
                    // Empty
        SEMICOLON:a
            {: RESULT = parser.nf.Empty(parser.util.pos(a)); :}
    ;
labeled_statement ::=
                    // Labeled
        IDENTIFIER:a COLON statement:b
            {: RESULT = parser.nf.Labeled(parser.util.pos(a),
	                                  a.getIdentifier(), b); :}
    ;
labeled_statement_no_short_if ::=
                    // Labeled
        IDENTIFIER:a COLON statement_no_short_if:b
            {: RESULT = parser.nf.Labeled(parser.util.pos(a),
	                                  a.getIdentifier(), b); :}
    ;
expression_statement ::=
                    // Stmt
        statement_expression:a SEMICOLON
            {: RESULT = parser.nf.Eval(parser.util.pos(a), a); :}
    ;
statement_expression ::=
                    // Expr
        assignment:a
            {: RESULT = a; :}
    |   preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   postincrement_expression:a
            {: RESULT = a; :}
    |   postdecrement_expression:a
            {: RESULT = a; :}
    |   method_invocation:a
            {: RESULT = a; :}
    |   class_instance_creation_expression:a
            {: RESULT = a; :}
    ;
if_then_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement:b
            {: RESULT = parser.nf.If(parser.util.pos(n), a, b); :}
    ;
if_then_else_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b
            ELSE statement:c
            {: RESULT = parser.nf.If(parser.util.pos(n), a, b, c); :}
    ;
if_then_else_statement_no_short_if ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b
            ELSE statement_no_short_if:c
            {: RESULT = parser.nf.If(parser.util.pos(n), a, b, c); :}
    ;
switch_statement ::=
                    // Switch
        SWITCH:n LPAREN expression:a RPAREN switch_block:b
            {: RESULT = parser.nf.Switch(parser.util.pos(n), a, b); :}
    ;
switch_block ::=
                    // List of SwitchElement
        LBRACE switch_block_statement_groups:a switch_labels:b RBRACE
            {: RESULT = a;
               a.addAll(b); :}
    |   LBRACE switch_block_statement_groups:a RBRACE
            {: RESULT = a; :}
    |   LBRACE switch_labels:a RBRACE
            {: RESULT = a; :}
    |   LBRACE RBRACE
            {: RESULT = new TypedList(new LinkedList(), SwitchElement.class, false); :}
    ;
switch_block_statement_groups ::=
                    // List of SwitchElement
        switch_block_statement_group:a
            {: RESULT = a; :}
    |   switch_block_statement_groups:a switch_block_statement_group:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
switch_block_statement_group ::=
                    // List of SwitchElement
        switch_labels:a block_statements:b
            {: List l = new TypedList(new LinkedList(), SwitchElement.class, false);
               l.addAll(a);
               l.add(parser.nf.SwitchBlock(parser.util.pos(a), b));
               RESULT = l; :}
    ;
switch_labels ::=
                    // List of Case
        switch_label:a
            {: List l = new TypedList(new LinkedList(), Case.class, false);
               l.add(a);
               RESULT = l; :}
    |   switch_labels:a switch_label:b
            {: RESULT = a;
               a.add(b); :}
    ;
switch_label ::=
                    // Case
        CASE:n constant_expression:a COLON
            {: RESULT = parser.nf.Case(parser.util.pos(n), a); :}
    |   DEFAULT:n COLON
            {: RESULT = parser.nf.Default(parser.util.pos(n)); :}
    ;

while_statement ::=
                    // While
        WHILE:n LPAREN expression:a RPAREN statement:b
            {: RESULT = parser.nf.While(parser.util.pos(n), a, b); :}
    ;
while_statement_no_short_if ::=
                    // While
        WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b
            {: RESULT = parser.nf.While(parser.util.pos(n), a, b); :}
    ;
do_statement ::=
                    // Do
        DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON
            {: RESULT = parser.nf.Do(parser.util.pos(n), a, b); :}
    ;
for_statement ::=
                    // For
        FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON
            for_update_opt:c RPAREN statement:d
            {: RESULT = parser.nf.For(parser.util.pos(n), a, b, c, d); :}
    ;
for_statement_no_short_if ::=
                    // For
        FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON
            for_update_opt:c RPAREN statement_no_short_if:d
            {: RESULT = parser.nf.For(parser.util.pos(n), a, b, c, d); :}
    ;
for_init_opt ::=
                    // List of ForInit
            {: RESULT = new TypedList(new LinkedList(), ForInit.class, false); :}
    |   for_init:a
            {: RESULT = a; :}
    ;
for_init ::=
                    // List of ForInit
        statement_expression_list:a
            {: RESULT = a; :}
    |   local_variable_declaration:a
            {: List l = new TypedList(new LinkedList(), ForInit.class, false);
               l.addAll(a);
               RESULT = l; :}
    ;
for_update_opt ::=
                    // List of ForUpdate
            {: RESULT = new TypedList(new LinkedList(), ForUpdate.class, false); :}
    |   for_update:a
            {: RESULT = a; :}
    ;
for_update ::=
                    // List of ForUpdate
        statement_expression_list:a
            {: RESULT = a; :}
    ;
statement_expression_list ::=
                    // List of Stmt
        statement_expression:a
            {: List l = new TypedList(new LinkedList(), Eval.class, false);
               l.add(parser.nf.Eval(parser.util.pos(a), a));
               RESULT = l; :}
    |   statement_expression_list:a COMMA statement_expression:b
            {: RESULT = a;
               a.add(parser.nf.Eval(parser.util.pos(b), b)); :}
    ;

identifier_opt ::=
                    // Name
            {: RESULT = null; :}
    |   IDENTIFIER:a
            {: RESULT = new Name(parser, parser.util.pos(a),
				a.getIdentifier()); :}
    ;

break_statement ::=
                    // Branch
        BREAK:n identifier_opt:a SEMICOLON
            {: if (a == null)
                   RESULT = parser.nf.Break(parser.util.pos(n));
               else
                   RESULT = parser.nf.Break(parser.util.pos(n), a.toString()); :}
    ;

continue_statement ::=
                    // Branch
        CONTINUE:n identifier_opt:a SEMICOLON
            {: if (a == null)
                   RESULT = parser.nf.Continue(parser.util.pos(n));
               else
                   RESULT = parser.nf.Continue(parser.util.pos(n), a.toString()); :}
    ;
return_statement ::=
                    // Return
        RETURN:n expression_opt:a SEMICOLON
            {: RESULT = parser.nf.Return(parser.util.pos(n), a); :}
    ;
throw_statement ::=
                    // Throw
        THROW:n expression:a SEMICOLON
            {: RESULT = parser.nf.Throw(parser.util.pos(n), a); :}
    ;
synchronized_statement ::=
                    // Synchronized
        SYNCHRONIZED:n LPAREN expression:a RPAREN block:b
            {: RESULT = parser.nf.Synchronized(parser.util.pos(n), a, b); :}
    ;
try_statement ::=
                    // Try
        TRY:n block:a catches:b
            {: RESULT = parser.nf.Try(parser.util.pos(n), a, b); :}
    |   TRY:n block:a catches_opt:b finally:c
            {: RESULT = parser.nf.Try(parser.util.pos(n), a, b, c); :}
    ;
catches_opt ::=
                    // List of Catch
            {: RESULT = new TypedList(new LinkedList(), Catch.class, false); :}
    |   catches:a
            {: RESULT = a; :}
    ;
catches ::=
                    // List of Catch
        catch_clause:a
            {: List l = new TypedList(new LinkedList(), Catch.class, false);
               l.add(a);
               RESULT = l; :}
    |   catches:a catch_clause:b
            {: RESULT = a;
               a.add(b); :}
    ;
catch_clause ::=
                    // Catch
        CATCH:n LPAREN formal_parameter:a RPAREN block:b
            {: RESULT = parser.nf.Catch(parser.util.pos(n), a, b); :}
    ;
finally ::=
                    // Block
        FINALLY block:a
            {: RESULT = a; :}
    ;

// 19.12) Expressions
primary ::=
                    // Expr
        primary_no_new_array:a
            {: RESULT = a; :}
    |   array_creation_expression:a
            {: RESULT = a; :}
    ;
primary_no_new_array ::=
                    // Expr
        literal:a
            {: RESULT = a; :}
    |   THIS:a
            {: RESULT = parser.nf.This(parser.util.pos(a)); :}
    |   LPAREN expression:a RPAREN
            {: RESULT = a; :}
    |   class_instance_creation_expression:a
            {: RESULT = a; :}
    |   field_access:a
            {: RESULT = a; :}
    |   method_invocation:a
            {: RESULT = a; :}
    |   array_access:a
            {: RESULT = a; :}
    |   primitive_type:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.util.pos(n), a, "class"); :}
    |   VOID:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.util.pos(n),
				parser.nf.CanonicalTypeNode(parser.util.pos(a),
				parser.ts.Void()), "class"); :}
    |   array_type:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.util.pos(n), a, "class"); :}
    |   name:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.util.pos(n), a.toType(), "class"); :}
    |   name:a DOT THIS:n
            {: RESULT = parser.nf.This(parser.util.pos(n), a.toType()); :}
    ;
class_instance_creation_expression ::=
                    // Expr
        NEW:n class_type:a LPAREN argument_list_opt:b RPAREN
            {: RESULT = parser.nf.New(parser.util.pos(n), a, b); :}
    |   NEW:n class_type:a LPAREN argument_list_opt:b RPAREN class_body:c
            {: RESULT = parser.nf.New(parser.util.pos(n), a, b, c); :}
    |   primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.QualifiedNew(parser.util.pos(a), a,
                                               b.toType(), c); :}
    |   primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
            {: RESULT = parser.nf.QualifiedNew(parser.util.pos(a), a,
                                               b.toType(), c, d); :}
    |   name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.QualifiedNew(parser.util.pos(a), a.toExpr(),
                                               b.toType(), c); :}
    |   name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
            {: RESULT = parser.nf.QualifiedNew(parser.util.pos(a), a.toExpr(),
                                               b.toType(), c, d); :}
    ;
argument_list_opt ::=
                    // List of Expr
            {: RESULT = new TypedList(new LinkedList(), Expr.class, false); :}
    |   argument_list:a
            {: RESULT = a; :}
    ;
argument_list ::=
                    // List of Expr
        expression:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; :}
    |   argument_list:a COMMA expression:b
            {: RESULT = a;
               a.add(b); :}
    ;
array_creation_expression ::=
                    // NewArray
        NEW:n primitive_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.util.pos(n), a, b,
	        	c.intValue()); :}
    |   NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.util.pos(n), a, b,
				c.intValue()); :}
    |   NEW:n primitive_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.util.pos(n), a,
	        	b.intValue(), c); :}
    |   NEW:n class_or_interface_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.util.pos(n), a,
	        	b.intValue(), c); :}
    ;
dim_exprs ::=
                    // List of Expr
        dim_expr:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; :}
    |   dim_exprs:a dim_expr:b
            {: RESULT = a;
               a.add(b); :}
    ;
dim_expr ::=
                    // Expr
        LBRACK expression:a RBRACK
            {: RESULT = a; :}
    ;
dims_opt ::=
                    // Integer
            {: RESULT = 0; :}
    |   dims:a
            {: RESULT = a; :}
    ;
dims ::=
                    // Integer
        LBRACK RBRACK
            {: RESULT = 1; :}
    |   dims:a LBRACK RBRACK
            {: RESULT = a + 1; :}
    ;
field_access ::=
                    // Field
        primary:a DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.util.pos(b), a,
	        	b.getIdentifier()); :}
    |   SUPER:n DOT IDENTIFIER:a
            {: RESULT = parser.nf.Field(parser.util.pos(a),
            	parser.nf.Super(parser.util.pos(n)),
				a.getIdentifier()); :}
    |   name:a DOT SUPER:n DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.util.pos(b),
				parser.nf.Super(parser.util.pos(n), a.toType()),
				b.getIdentifier()); :}
    ;
method_invocation ::=
                    // Call
        name:a LPAREN argument_list_opt:b RPAREN
            {: RESULT = parser.nf.Call(parser.util.pos(a),
	    		a.prefix == null ? null : a.prefix.toReceiver(),
	        	a.name, b); :}
    |   primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.Call(parser.util.pos(b), a,
	        	b.getIdentifier(), c); :}
    |   SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.Call(parser.util.pos(b),
            	parser.nf.Super(parser.util.pos(a)),
                b.getIdentifier(), c); :}
    |   name:a DOT SUPER:n DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.Call(parser.util.pos(b),
            	parser.nf.Super(parser.util.pos(n), a.toType()),
                b.getIdentifier(), c); :}
    ;
array_access ::=
                    // ArrayAccess
        name:a LBRACK expression:b RBRACK
            {: RESULT = parser.nf.ArrayAccess(parser.util.pos(a), a.toExpr(), b); :}
    |   primary_no_new_array:a LBRACK expression:b RBRACK
            {: RESULT = parser.nf.ArrayAccess(parser.util.pos(a), a, b); :}
    ;
postfix_expression ::=
                    // Expr
        primary:a
            {: RESULT = a; :}
    |   name:a
            {: RESULT = a.toExpr(); :}
    |   postincrement_expression:a
            {: RESULT = a; :}
    |   postdecrement_expression:a
            {: RESULT = a; :}
    ;
postincrement_expression ::=
                    // Unary
        postfix_expression:a PLUSPLUS
            {: RESULT = parser.nf.Unary(parser.util.pos(a), a, Unary.POST_INC); :}
    ;
postdecrement_expression ::=
                    // Unary
        postfix_expression:a MINUSMINUS
            {: RESULT = parser.nf.Unary(parser.util.pos(a), a, Unary.POST_DEC); :}
    ;
unary_expression ::=
                    // Expr
        preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   PLUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.util.pos(a), Unary.POS, a); :}
    |   MINUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.util.pos(a), Unary.NEG, a); :}
    |   unary_expression_not_plus_minus:a
            {: RESULT = a; :}
    ;
preincrement_expression ::=
                    // Unary
        PLUSPLUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.util.pos(a), Unary.PRE_INC, a); :}
    ;
predecrement_expression ::=
                    // Unary
        MINUSMINUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.util.pos(a), Unary.PRE_DEC, a); :}
    ;
unary_expression_not_plus_minus ::=
                    // Expr
        postfix_expression:a
            {: RESULT = a; :}
    |   COMP unary_expression:a
            {: RESULT = parser.nf.Unary(parser.util.pos(a), Unary.BIT_NOT, a); :}
    |   NOT unary_expression:a
            {: RESULT = parser.nf.Unary(parser.util.pos(a), Unary.NOT, a); :}
    |   cast_expression:a
            {: RESULT = a; :}
    ;
cast_expression ::=
                    // Cast
        LPAREN primitive_type:a dims_opt:b RPAREN unary_expression:c
            {: RESULT = parser.nf.Cast(parser.util.pos(a),
            	parser.util.array(a, b.intValue()), c); :}
    |   LPAREN expression:a RPAREN unary_expression_not_plus_minus:b
            {: RESULT = parser.nf.Cast(parser.util.pos(a),
            	parser.util.exprToType(a), b); :}
    |   LPAREN name:a dims:b RPAREN unary_expression_not_plus_minus:c
            {: RESULT = parser.nf.Cast(parser.util.pos(a),
            	parser.util.array(a.toType(), b.intValue()), c); :}
    ;
multiplicative_expression ::=
                    // Expr
        unary_expression:a
            {: RESULT = a; :}
    |   multiplicative_expression:a MULT unary_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.MUL, b); :}
    |   multiplicative_expression:a DIV unary_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.DIV, b); :}
    |   multiplicative_expression:a MOD unary_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.MOD, b); :}
    ;
additive_expression ::=
                    // Expr
        multiplicative_expression:a
            {: RESULT = a; :}
    |   additive_expression:a PLUS multiplicative_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.ADD, b); :}
    |   additive_expression:a MINUS multiplicative_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.SUB, b); :}
    ;
shift_expression ::=
                    // Expr
        additive_expression:a
            {: RESULT = a; :}
    |   shift_expression:a LSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.SHL, b); :}
    |   shift_expression:a RSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.SHR, b); :}
    |   shift_expression:a URSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.USHR, b); :}
    ;
relational_expression ::=
                    // Expr
        shift_expression:a
            {: RESULT = a; :}
    |   relational_expression:a LT shift_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.LT, b); :}
    |   relational_expression:a GT shift_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.GT, b); :}
    |   relational_expression:a LTEQ shift_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.LE, b); :}
    |   relational_expression:a GTEQ shift_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.GE, b); :}
    |   relational_expression:a INSTANCEOF reference_type:b
            {: RESULT = parser.nf.Instanceof(parser.util.pos(a), a, b); :}
    ;

equality_expression ::=
                    // Expr
        relational_expression:a
            {: RESULT = a; :}
    |   equality_expression:a EQEQ relational_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.EQ, b); :}
    |   equality_expression:a NOTEQ relational_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.NE, b); :}
    ;
and_expression ::=
                    // Expr
        equality_expression:a
            {: RESULT = a; :}
    |   and_expression:a AND equality_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.BIT_AND, b); :}
    ;
exclusive_or_expression ::=
                    // Expr
        and_expression:a
            {: RESULT = a; :}
    |   exclusive_or_expression:a XOR and_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.BIT_XOR, b); :}
    ;
inclusive_or_expression ::=
                    // Expr
        exclusive_or_expression:a
            {: RESULT = a; :}
    |   inclusive_or_expression:a OR exclusive_or_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.BIT_OR, b); :}
    ;
conditional_and_expression ::=
                    // Expr
        inclusive_or_expression:a
            {: RESULT = a; :}
    |   conditional_and_expression:a ANDAND inclusive_or_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.COND_AND, b); :}
    ;
conditional_or_expression ::=
                    // Expr
        conditional_and_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a OROR conditional_and_expression:b
            {: RESULT = parser.nf.Binary(parser.util.pos(a), a,
				Binary.COND_OR, b); :}
    ;
conditional_expression ::=
                    // Expr
        conditional_or_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a QUESTION expression:b
            COLON conditional_expression:c
            {: RESULT = parser.nf.Conditional(parser.util.pos(a), a,
				b, c); :}
    ;
assignment_expression ::=
                    // Expr
        conditional_expression:a
            {: RESULT = a; :}
    |   assignment:a
            {: RESULT = a; :}
    ;
assignment ::=
                    // Expr
        left_hand_side:a assignment_operator:b assignment_expression:c
            {: RESULT = parser.nf.Assign(parser.util.pos(a), a, b, c); :}
    ;
left_hand_side ::=
                    // Expr
        name:a
            {: RESULT = a.toExpr(); :}
    |   field_access:a
            {: RESULT = a; :}
    |   array_access:a
            {: RESULT = a; :}
    ;
assignment_operator ::=
                    // Assign.Operator
        EQ
            {: RESULT = Assign.ASSIGN; :}
    |   MULTEQ
            {: RESULT = Assign.MUL_ASSIGN; :}
    |   DIVEQ
            {: RESULT = Assign.DIV_ASSIGN; :}
    |   MODEQ
            {: RESULT = Assign.MOD_ASSIGN; :}
    |   PLUSEQ
            {: RESULT = Assign.ADD_ASSIGN; :}
    |   MINUSEQ
            {: RESULT = Assign.SUB_ASSIGN; :}
    |   LSHIFTEQ
            {: RESULT = Assign.SHL_ASSIGN; :}
    |   RSHIFTEQ
            {: RESULT = Assign.SHR_ASSIGN; :}
    |   URSHIFTEQ
            {: RESULT = Assign.USHR_ASSIGN; :}
    |   ANDEQ
            {: RESULT = Assign.BIT_AND_ASSIGN; :}
    |   XOREQ
            {: RESULT = Assign.BIT_XOR_ASSIGN; :}
    |   OREQ
            {: RESULT = Assign.BIT_OR_ASSIGN; :}
    ;
expression_opt ::=
					// Expr
			{: RESULT = null; :}
	|	expression:a
			{: RESULT = a; :}
	;
expression ::=
                    // Expr
        assignment_expression:a
            {: RESULT = a; :}
    ;
constant_expression ::=
                    // Expr
        expression:a
            {: RESULT = a; :}
    ;
